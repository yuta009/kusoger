<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>異世界決戦：三界衝突（トライ・クラッシュ）</title>
    <style>
      :root {
        color-scheme: dark;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #0b0b10;
        font-family: "Segoe UI", "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif;
        overflow: hidden;
      }
      #game {
        display: block;
        width: 100%;
        height: 100%;
      }
      .overlay {
        position: fixed;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 16px;
        text-align: center;
        color: #e6e8ff;
        pointer-events: none;
        text-shadow: 0 0 12px rgba(120, 120, 255, 0.35);
      }
      .overlay .title {
        font-size: clamp(20px, 4vw, 36px);
        letter-spacing: 0.1em;
      }
      .overlay .hint {
        font-size: clamp(12px, 2vw, 16px);
        opacity: 0.7;
        line-height: 1.6;
      }
      .overlay .badge {
        margin-top: 8px;
        font-size: clamp(28px, 6vw, 56px);
        color: #fff;
      }
      .overlay .sub {
        font-size: clamp(12px, 2.3vw, 18px);
        opacity: 0.85;
      }
      .overlay button {
        pointer-events: auto;
        padding: 10px 20px;
        border: 1px solid rgba(120, 120, 255, 0.5);
        background: rgba(24, 24, 40, 0.7);
        color: #e6e8ff;
        border-radius: 999px;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      .overlay button:hover {
        transform: translateY(-1px);
        box-shadow: 0 0 20px rgba(120, 120, 255, 0.3);
      }
      .corner {
        position: fixed;
        left: 16px;
        bottom: 16px;
        color: rgba(230, 232, 255, 0.6);
        font-size: 12px;
        letter-spacing: 0.08em;
      }
      .timer {
        position: fixed;
        left: 50%;
        top: calc(50% + 180px);
        color: rgba(230, 232, 255, 0.85);
        font-size: 14px;
        letter-spacing: 0.08em;
        text-shadow: 0 0 12px rgba(120, 120, 255, 0.35);
        transform: translateX(-50%);
      }
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>
    <div class="overlay" id="overlay">
      <div class="title">異世界決戦：三界衝突</div>
      <div class="hint">
        A / S / D で三者の圧力を弾く<br />
        スマホはスワイプ操作
      </div>
      <button id="startButton">開始</button>
    </div>
    <div class="corner">残り時間表示 / 直感バランス</div>
    <div class="timer" id="timer"></div>
    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const overlay = document.getElementById("overlay");
      const startButton = document.getElementById("startButton");
      const timer = document.getElementById("timer");

      const config = {
        duration: 60,
        coreRadius: 30,
        maxDist: 220,
        pulseSpeed: 2.8,
        fatigueGain: 0.25,
        fatigueDecay: 0.5,
        impulseDecay: 2.4,
        impulseScale: 520,
        centerPull: 0.42,
        forceScale: 300,
        wobbleScale: 140,
        turbulenceScale: 160,
        sourceJitter: 26,
      };

      const state = {
        width: 0,
        height: 0,
        centerX: 0,
        centerY: 0,
        time: 0,
        stability: 1,
        core: { x: 0, y: 0, vx: 0, vy: 0 },
        impulse: { leon: 0, goddess: 0, sato: 0 },
        forces: { leon: 0, goddess: 0, sato: 0 },
        fatigue: 0,
        lastInputAt: 0,
        running: false,
        ended: false,
        rank: null,
        pulseOffset: Math.random() * Math.PI * 2,
        message: "",
        bestRank: null,
      };

      const ranks = [
        { key: "S", label: "完全制御（世界のみ残る）" },
        { key: "A", label: "二者相殺" },
        { key: "B", label: "世界半壊" },
        { key: "C", label: "世界崩壊・三者存続" },
        { key: "D", label: "世界無化" },
      ];

      const imagePaths = {
        leon: "picture/maou.png",
        goddess: "picture/megami.png",
        sato: "picture/takesi.png",
        core: "picture/ball.png",
        leonAtk: "picture/maou_at.png",
        goddessAtk: "picture/megami_at.png",
        satoAtk: "picture/takesi_at.png",
      };

      const images = Object.fromEntries(
        Object.entries(imagePaths).map(([key, src]) => {
          const img = new Image();
          img.src = src;
          return [key, img];
        })
      );

      let imagesReady = false;
      function loadImages() {
        const loaders = Object.values(images).map(
          (img) =>
            new Promise((resolve) => {
              if (img.complete) return resolve();
              img.onload = () => resolve();
              img.onerror = () => resolve();
            })
        );
        return Promise.all(loaders).then(() => {
          imagesReady = true;
        });
      }

      function resize() {
        canvas.width = window.innerWidth * devicePixelRatio;
        canvas.height = window.innerHeight * devicePixelRatio;
        canvas.style.width = `${window.innerWidth}px`;
        canvas.style.height = `${window.innerHeight}px`;
        state.width = canvas.width;
        state.height = canvas.height;
        state.centerX = state.width / 2;
        state.centerY = state.height / 2;
      }
      window.addEventListener("resize", resize);
      resize();

      function resetGame() {
        state.time = 0;
        state.stability = 1;
        state.core.x = state.centerX;
        state.core.y = state.centerY;
        state.core.vx = 0;
        state.core.vy = 0;
        state.impulse.leon = 0;
        state.impulse.goddess = 0;
        state.impulse.sato = 0;
        state.forces.leon = 0;
        state.forces.goddess = 0;
        state.forces.sato = 0;
        state.fatigue = 0;
        state.lastInputAt = 0;
        state.running = true;
        state.ended = false;
        state.rank = null;
        state.message = "";
        state.pulseOffset = Math.random() * Math.PI * 2;
        if (timer) timer.textContent = `残り ${config.duration} 秒`;
      }

      function difficultyFactor() {
        const t = Math.min(state.time / config.duration, 1);
        return 0.85 + t * 0.85;
      }

      function applyImpulse(type) {
        const now = performance.now() / 1000;
        const spam = now - state.lastInputAt < 0.12;
        state.lastInputAt = now;
        state.fatigue = Math.min(1, state.fatigue + config.fatigueGain);

        const penalty = spam ? 0.1 : 0;
        if (penalty > 0) {
          state.stability = Math.max(0, state.stability - penalty);
        }

        const strength = 1.15 * (1 - state.fatigue * 0.35);
        state.impulse[type] = Math.min(1.8, state.impulse[type] + strength);
      }

      function handleKey(e) {
        if (!state.running) return;
        if (e.code === "KeyA") applyImpulse("leon");
        if (e.code === "KeyS") applyImpulse("goddess");
        if (e.code === "KeyD") applyImpulse("sato");
      }
      window.addEventListener("keydown", handleKey);

      let touchStart = null;
      canvas.addEventListener("pointerdown", (e) => {
        if (!state.running) return;
        touchStart = { x: e.clientX, y: e.clientY, t: performance.now() };
      });
      canvas.addEventListener("pointerup", (e) => {
        if (!state.running || !touchStart) return;
        const dx = e.clientX - touchStart.x;
        const dy = e.clientY - touchStart.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 18) {
          const rect = canvas.getBoundingClientRect();
          const cx = rect.left + rect.width / 2;
          const cy = rect.top + rect.height / 2;
          const cdist = Math.hypot(e.clientX - cx, e.clientY - cy);
          touchStart = null;
          return;
        }
        if (Math.abs(dx) > Math.abs(dy)) {
          if (dx < 0) applyImpulse("leon");
          else applyImpulse("goddess");
        } else {
          if (dy > 0) applyImpulse("sato");
        }
        touchStart = null;
      });

      function update(dt) {
        if (!state.running) return;
        state.time += dt;
        state.fatigue = Math.max(0, state.fatigue - config.fatigueDecay * dt);
        const difficulty = difficultyFactor();
        const t = state.time;
        const noise = (amp, speed, phase) => amp * Math.sin(t * speed + phase);
        const vectorToward = (source, target, power, scale) => {
          const dx = source.x - target.x;
          const dy = source.y - target.y;
          const dist = Math.max(1, Math.hypot(dx, dy));
          const nx = dx / dist;
          const ny = dy / dist;
          return { x: nx * power * scale, y: ny * power * scale };
        };
        const vectorAway = (source, target, power, scale) => {
          const dx = target.x - source.x;
          const dy = target.y - source.y;
          const dist = Math.max(1, Math.hypot(dx, dy));
          const nx = dx / dist;
          const ny = dy / dist;
          return { x: nx * power * scale, y: ny * power * scale };
        };

        const leonBase = 0.95 + noise(0.35, 1.2, 0.3);
        const goddessBase = 0.9 + noise(0.4, 1.5, 2.1);
        const satoBase = 0.9 + noise(0.55, 1.9, 1.3);

        const leon = Math.max(0.2, leonBase * difficulty - state.impulse.leon);
        const goddess = Math.max(
          0.2,
          goddessBase * difficulty - state.impulse.goddess
        );
        const sato = Math.max(0.2, satoBase * difficulty - state.impulse.sato);

        state.forces.leon = leon;
        state.forces.goddess = goddess;
        state.forces.sato = sato;

        state.impulse.leon = Math.max(0, state.impulse.leon - config.impulseDecay * dt);
        state.impulse.goddess = Math.max(0, state.impulse.goddess - config.impulseDecay * dt);
        state.impulse.sato = Math.max(0, state.impulse.sato - config.impulseDecay * dt);

        const wobble = noise(0.6, 3.2, 4.2);
        const jitter = config.sourceJitter;
        const sources = {
          leon: {
            x: state.centerX + Math.sin(t * 1.7 + 0.2) * jitter,
            y: state.centerY - config.maxDist + Math.cos(t * 1.5 + 1.1) * jitter,
          },
          goddess: {
            x: state.centerX - config.maxDist + Math.cos(t * 1.6 + 2.4) * jitter,
            y: state.centerY + Math.sin(t * 1.3 + 0.4) * jitter,
          },
          sato: {
            x: state.centerX + config.maxDist + Math.sin(t * 1.8 + 3.2) * jitter,
            y: state.centerY + Math.cos(t * 1.4 + 2.7) * jitter,
          },
        };
        const forceScale = config.forceScale;
        const leonVec = vectorToward(sources.leon, state.core, leon, forceScale);
        const goddessVec = vectorToward(
          sources.goddess,
          state.core,
          goddess,
          forceScale
        );
        const satoVec = vectorToward(sources.sato, state.core, sato, forceScale);
        const leonImpulse = vectorAway(
          sources.leon,
          state.core,
          state.impulse.leon,
          config.impulseScale
        );
        const goddessImpulse = vectorAway(
          sources.goddess,
          state.core,
          state.impulse.goddess,
          config.impulseScale
        );
        const satoImpulse = vectorAway(
          sources.sato,
          state.core,
          state.impulse.sato,
          config.impulseScale
        );

        const turbulenceX =
          (noise(0.7, 4.2, 1.7) + noise(0.4, 7.3, 0.2)) *
          config.turbulenceScale;
        const turbulenceY =
          (noise(0.7, 4.4, 2.7) + noise(0.35, 6.9, 1.1)) *
          config.turbulenceScale;
        const forceX =
          leonVec.x +
          goddessVec.x +
          satoVec.x +
          leonImpulse.x +
          goddessImpulse.x +
          satoImpulse.x +
          wobble * config.wobbleScale +
          turbulenceX;
        const forceY =
          leonVec.y +
          goddessVec.y +
          satoVec.y +
          leonImpulse.y +
          goddessImpulse.y +
          satoImpulse.y +
          noise(0.26, 3.5, 0.6) * config.wobbleScale +
          turbulenceY;

        const centerDX = state.centerX - state.core.x;
        const centerDY = state.centerY - state.core.y;
        const centerDist = Math.max(1, Math.hypot(centerDX, centerDY));
        const centerNX = centerDX / centerDist;
        const centerNY = centerDY / centerDist;
        const centerForce = config.centerPull * centerDist;

        state.core.vx += (forceX + centerNX * centerForce) * dt;
        state.core.vy += (forceY + centerNY * centerForce) * dt;
        state.core.vx *= 0.78;
        state.core.vy *= 0.78;
        state.core.x += state.core.vx * dt;
        state.core.y += state.core.vy * dt;

        let dx = state.core.x - state.centerX;
        let dy = state.core.y - state.centerY;
        let dist = Math.hypot(dx, dy);
        if (dist > config.maxDist) {
          const nx = dx / dist;
          const ny = dy / dist;
          state.core.x = state.centerX + nx * config.maxDist;
          state.core.y = state.centerY + ny * config.maxDist;
          state.core.vx *= 0.4;
          state.core.vy *= 0.4;
          dx = state.core.x - state.centerX;
          dy = state.core.y - state.centerY;
          dist = Math.hypot(dx, dy);
        }
        if (!Number.isFinite(dist)) {
          state.core.x = state.centerX;
          state.core.y = state.centerY;
          state.core.vx = 0;
          state.core.vy = 0;
          dx = 0;
          dy = 0;
          dist = 0;
        }
        const strain = Math.min(dist / config.maxDist, 1);
        state.stability -= strain * dt * 0.45 * difficulty;
        state.stability += (1 - strain) * dt * 0.12;
        state.stability = Math.max(0, Math.min(1, state.stability));

        if (state.stability <= 0) {
          endGame(false);
        } else if (state.time >= config.duration) {
          endGame(true);
        }

        if (timer) {
          const remain = Math.max(0, config.duration - state.time);
          timer.textContent = `残り ${Math.ceil(remain)} 秒`;
        }
      }

      function endGame(win) {
        if (state.ended) return;
        state.running = false;
        state.ended = true;
        const stability = state.stability;
        let rank = ranks[4];
        if (win) {
          if (stability > 0.86) rank = ranks[0];
          else if (stability > 0.7) rank = ranks[1];
          else if (stability > 0.5) rank = ranks[2];
          else if (stability > 0.3) rank = ranks[3];
          else rank = ranks[4];
        }
        state.rank = rank;
        updateBest(rank.key);
        renderOverlay(win);
        if (timer) timer.textContent = "残り 0 秒";
      }

      function updateBest(key) {
        const order = ["S", "A", "B", "C", "D"];
        const best = localStorage.getItem("tri-crash-best");
        if (!best || order.indexOf(key) < order.indexOf(best)) {
          localStorage.setItem("tri-crash-best", key);
        }
        state.bestRank = localStorage.getItem("tri-crash-best");
      }

      function renderOverlay(win) {
        overlay.innerHTML = `
          <div class="title">${win ? "均衡維持" : "臨界崩壊"}</div>
          <div class="badge">${state.rank.key}</div>
          <div class="sub">${state.rank.label}</div>
          <div class="hint">最良ランク：${state.bestRank || state.rank.key}</div>
          <button id="restartButton">再開</button>
        `;
        overlay.style.display = "flex";
        const restartButton = document.getElementById("restartButton");
        restartButton.addEventListener("click", () => {
          overlay.style.display = "none";
          overlay.innerHTML = "";
          resetGame();
        });
      }

      function draw(time) {
        const t = time / 1000;
        const dt = Math.min(0.033, t - (state.lastTime || t));
        state.lastTime = t;
        update(dt);

        ctx.clearRect(0, 0, state.width, state.height);
        ctx.save();
        ctx.scale(devicePixelRatio, devicePixelRatio);

        const cx = state.centerX / devicePixelRatio;
        const cy = state.centerY / devicePixelRatio;
        const viewW = state.width / devicePixelRatio;
        const viewH = state.height / devicePixelRatio;
        const shake = (1 - state.stability) * 8;
        ctx.translate(
          (Math.random() - 0.5) * shake,
          (Math.random() - 0.5) * shake
        );

        const pulse = Math.sin(state.time * config.pulseSpeed + state.pulseOffset);
        const coreDist =
          Math.hypot(
            state.core.x / devicePixelRatio - cx,
            state.core.y / devicePixelRatio - cy
          ) / (config.maxDist / devicePixelRatio);
        const danger = Math.min(1, coreDist);

        const coreX = state.core.x / devicePixelRatio;
        const coreY = state.core.y / devicePixelRatio;

        const ringRadiusView = config.maxDist / devicePixelRatio;
        const avatarSize = Math.min(160, Math.max(80, viewW * 0.12));
        const outside = ringRadiusView + avatarSize * 0.65;
        const sourcesView = {
          leon: {
            x: cx,
            y: cy - outside,
          },
          goddess: {
            x: cx - outside,
            y: cy,
          },
          sato: {
            x: cx + outside,
            y: cy,
          },
        };

        if (imagesReady) {
          const fade = 0.7 + (1 - danger) * 0.2;

          ctx.save();
          ctx.globalAlpha = fade;
          ctx.drawImage(
            images.leon,
            sourcesView.leon.x - avatarSize / 2,
            sourcesView.leon.y - avatarSize / 2,
            avatarSize,
            avatarSize
          );
          ctx.drawImage(
            images.goddess,
            sourcesView.goddess.x - avatarSize / 2,
            sourcesView.goddess.y - avatarSize / 2,
            avatarSize,
            avatarSize
          );
          ctx.drawImage(
            images.sato,
            sourcesView.sato.x - avatarSize / 2,
            sourcesView.sato.y - avatarSize / 2,
            avatarSize,
            avatarSize
          );
          ctx.restore();

          const attackSize = avatarSize * 0.9;
          const attacks = [
            {
              img: images.leonAtk,
              source: sourcesView.leon,
              power: state.forces.leon,
              flipX: false,
            },
            {
              img: images.goddessAtk,
              source: sourcesView.goddess,
              power: state.forces.goddess,
              flipX: false,
            },
            {
              img: images.satoAtk,
              source: sourcesView.sato,
              power: state.forces.sato,
              flipX: true,
            },
          ];

          attacks.forEach((attack) => {
            const dx = coreX - attack.source.x;
            const dy = coreY - attack.source.y;
            const dist = Math.max(1, Math.hypot(dx, dy));
            const nx = dx / dist;
            const ny = dy / dist;
            const minOffset = avatarSize * 0.9;
            const offset = Math.max(
              minOffset,
              Math.min(dist * 0.55, attackSize * 1.6)
            );
            const ax = attack.source.x + nx * offset;
            const ay = attack.source.y + ny * offset;
            const alpha = 0.35 + Math.min(1, attack.power) * 0.65;

            ctx.save();
            ctx.translate(ax, ay);
            ctx.globalAlpha = alpha;
            if (attack.flipX) {
              ctx.scale(-1, 1);
            }
            ctx.drawImage(
              attack.img,
              -attackSize / 2,
              -attackSize / 2,
              attackSize,
              attackSize
            );
            ctx.restore();
          });
        }

        const beamColors = {
          leon: "rgba(255, 90, 90, ",
          goddess: "rgba(120, 170, 255, ",
          sato: "rgba(90, 90, 110, ",
        };
        const beamForces = state.forces;
        Object.keys(beamForces).forEach((key) => {
          const power = Math.min(1, beamForces[key]);
          const alpha = 0.15 + power * 0.55;
          ctx.beginPath();
          ctx.moveTo(sourcesView[key].x, sourcesView[key].y);
          ctx.lineTo(coreX, coreY);
          ctx.strokeStyle = `${beamColors[key]}${alpha})`;
          ctx.lineWidth = 2 + power * 4;
          ctx.stroke();
        });

        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, config.maxDist / devicePixelRatio, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(80, 220, 255, 0.85)";
        ctx.lineWidth = 4;
        ctx.shadowColor = "rgba(80, 220, 255, 0.5)";
        ctx.shadowBlur = 12;
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(cx, cy, 8, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(235, 245, 255, 0.95)";
        ctx.fill();
        ctx.restore();


        const ringRadius =
          config.coreRadius + 18 + (pulse * 6 + danger * 10);
        ctx.beginPath();
        ctx.arc(coreX, coreY, ringRadius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(140, 180, 255, ${0.2 + Math.abs(pulse) * 0.4})`;
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.save();
        ctx.beginPath();
        ctx.arc(coreX, coreY, 16 + danger * 10, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
        ctx.shadowColor = "rgba(140, 190, 255, 0.7)";
        ctx.shadowBlur = 18;
        ctx.fill();
        ctx.strokeStyle = "rgba(100, 160, 255, 0.95)";
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.restore();


        const gradient = ctx.createRadialGradient(
          coreX,
          coreY,
          8,
          coreX,
          coreY,
          config.coreRadius + 20
        );
        gradient.addColorStop(0, `rgba(240, 240, 255, 0.9)`);
        gradient.addColorStop(
          0.4,
          `rgba(${140 + danger * 80}, ${80 + danger * 40}, ${
            160 - danger * 80
          }, 0.8)`
        );
        gradient.addColorStop(
          1,
          `rgba(${120 + danger * 100}, ${120 - danger * 40}, ${
            180 - danger * 100
          }, 0.1)`
        );

        ctx.beginPath();
        const wobble = 1 + Math.sin(t * 4 + pulse * 2) * 0.15 + danger * 0.2;
        ctx.ellipse(
          coreX,
          coreY,
          config.coreRadius * (1.1 + wobble),
          config.coreRadius * (0.9 + danger * 0.4),
          t * 0.8,
          0,
          Math.PI * 2
        );
        ctx.fillStyle = gradient;
        ctx.fill();

        if (imagesReady) {
          const coreSize =
            (config.coreRadius * 2.6) *
            (1 + danger * 0.35 + Math.abs(pulse) * 0.12);
          ctx.save();
          ctx.translate(coreX, coreY);
          ctx.rotate(t * 0.5);
          ctx.globalAlpha = 0.85;
          ctx.drawImage(
            images.core,
            -coreSize / 2,
            -coreSize / 2,
            coreSize,
            coreSize
          );
          ctx.restore();
        }

        const trailCount = 12;
        for (let i = 0; i < trailCount; i++) {
          const angle = (Math.PI * 2 * i) / trailCount + t;
          const rad = config.coreRadius + 30 + danger * 20;
          const px = coreX + Math.cos(angle) * rad;
          const py = coreY + Math.sin(angle) * rad;
          ctx.beginPath();
          ctx.arc(px, py, 2 + danger * 2, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(120, 120, 255, ${0.08 + danger * 0.12})`;
          ctx.fill();
        }

        ctx.restore();

        if (state.running) {
          requestAnimationFrame(draw);
        }
      }

      startButton.addEventListener("click", async () => {
        startButton.disabled = true;
        startButton.textContent = "読み込み中...";
        await loadImages();
        overlay.style.display = "none";
        resetGame();
        requestAnimationFrame(draw);
      });

      updateBest("D");
    </script>
  </body>
</html>
