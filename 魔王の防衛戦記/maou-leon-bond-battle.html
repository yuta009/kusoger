<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é­”ç‹ã¨ãƒ¬ã‚ªãƒ³ï¼šçµ†é€£é–ãƒãƒˆãƒ«</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #11081f;
            /* Fallback */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            color: white;
        }

        #gameContainer {
            position: relative;
            background: black;
            border: 4px solid #A088FF;
            box-shadow: 0 0 50px rgba(160, 136, 255, 0.3);
            overflow: hidden;
            /* ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒã—ãªãŒã‚‰ç”»é¢ã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹ */
            aspect-ratio: 1200 / 800;
            width: min(1200px, 100vw);
            height: min(800px, 100vh);
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #uiLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .ui-header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 80px;
            background: url('picture/Frame1.png') no-repeat center top;
            background-size: 100% 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 40px;
            z-index: 10;
        }

        .score-box {
            font-size: 20px;
            font-weight: bold;
            color: #FFE7FF;
            text-shadow: 0 0 5px #A088FF;
        }

        .center-ui {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 400px;
        }

        .bond-text {
            font-size: 14px;
            margin-bottom: 5px;
            color: #C5A9FF;
        }

        .bond-gauge-container {
            width: 100%;
            height: 15px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #A088FF;
            border-radius: 8px;
            padding: 2px;
            position: relative;
        }

        .bond-gauge-fill {
            height: 100%;
            background: linear-gradient(90deg, #5544DD 0%, #C5A9FF 50%, #FFE7FF 100%);
            width: 0%;
            border-radius: 6px;
            transition: width 0.2s;
            box-shadow: 0 0 10px #C5A9FF;
        }

        .timer-box {
            font-size: 24px;
            font-weight: bold;
            color: #FFE7FF;
        }

        .warning {
            color: #ff4444;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.1);
                opacity: 0.8;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(17, 8, 31, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 20;
            transition: opacity 0.5s;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        .logo-img {
            max-width: min(500px, 80vw);
            max-height: min(180px, 20vh);
            margin-bottom: 10px;
            margin-top: 10px;
            width: auto;
            filter: drop-shadow(0 0 20px rgba(160, 136, 255, 0.6));
        }

        .btn-container {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        .game-btn {
            width: min(160px, 30vw);
            height: min(50px, 8vh);
            min-width: 120px;
            min-height: 40px;
            background: linear-gradient(180deg, #A088FF 0%, #5544DD 100%);
            border: 2px solid #C5A9FF;
            border-radius: 25px;
            color: white;
            font-size: clamp(14px, 2.5vw, 18px);
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            display: flex;
            justify-content: center;
            align-items: center;
            text-shadow: 1px 1px 2px black;
            z-index: 100;
        }

        .game-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px #C5A9FF;
        }

        .game-btn:active {
            transform: scale(0.95);
        }

        .story-text {
            max-width: min(600px, 90vw);
            margin-bottom: 15px;
            text-align: center;
            line-height: 1.4;
            color: #eee;
            background: rgba(0, 0, 0, 0.5);
            padding: 12px;
            border-radius: 10px;
            border: 1px solid #553377;
            font-size: clamp(11px, 2vw, 14px);
        }

        #loadingScreen {
            background: #11081f;
            z-index: 100;
        }

        .loading-bar {
            width: 300px;
            height: 4px;
            background: #333;
            margin-top: 20px;
        }

        .loading-progress {
            height: 100%;
            background: #A088FF;
            width: 0%;
            transition: width 0.1s;
        }
    </style>
</head>

<body>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="800"></canvas>

        <!-- UI Layer -->
        <div id="uiLayer">
            <div class="ui-header">
                <div class="score-box">SCORE: <span id="scoreVal">0</span></div>
                <div class="center-ui">
                    <div class="bond-text">BOND CONNECT: <span id="bondCount">0</span>/6</div>
                    <div class="bond-gauge-container">
                        <div class="bond-gauge-fill" id="bondBar"></div>
                    </div>
                    <div class="bond-text" style="margin-top: 5px; font-size: 12px;">HP: <span id="playerHp">100</span>/100</div>
                    <div id="specialAttackInfo" class="bond-text" style="margin-top: 5px; font-size: 11px; color: #FFD700; display: none;">
                        å¿…æ®ºæŠ€: <span id="specialAttackUses">5</span>/5 (Fã‚­ãƒ¼)
                    </div>
                </div>
                <div class="timer-box" id="timerBox"><span id="timerVal">3:00</span></div>
            </div>
        </div>

        <!-- Loading Screen -->
        <div id="loadingScreen" class="screen">
            <div style="font-size: 24px; color: #A088FF;">LOADING DATA...</div>
            <div class="loading-bar">
                <div class="loading-progress" id="loadProg"></div>
            </div>
        </div>

        <!-- Title Screen -->
        <div id="titleScreen" class="screen hidden">
            <img src="picture/title_logo.png" class="logo-img" alt="Title Logo">

            <div class="story-text">
                å¹³å’Œãªç”ºã‚’ç¯‰ãã€å­ã©ã‚‚ãŸã¡ã‚’è‚²ã¦ã¦ã„ãŸé­”ç‹ã®å›½ã€‚<br>
                ã—ã‹ã—çªå¦‚ã€å¥³ç¥ãŒç¥è–å…µå™¨ã€Œãƒ©ãƒ¼ãƒ ãƒ–ãƒªãƒ¤ãƒ³ãƒˆã€ã‚’æºãˆã€ç©ºã‹ã‚‰ä¾µæ”»ã—ã¦ããŸã€‚<br>
                çµ¶æœ›çš„ãªå…‰ã®å¥”æµã«å¯¾æŠ—ã™ã¹ãã€é­”ç‹ã¯æœ€å¼·ã®æˆ¦å£«ã€Œãƒ¬ã‚ªãƒ³ã€ã¨è»å›£ã‚’æ´¾é£ã€‚<br><br>
                ãƒ¬ã‚ªãƒ³ã¯ä»²é–“ãŸã¡ã¨"çµ†"ã‚’ç¹‹ããªãŒã‚‰åŠ›ã‚’å¢—å¹…ã•ã›ã€å¥³ç¥ã®æ©Ÿæ¢°å…µå›£ã‚’æ‰“ã¡å€’ã—ã¦ã„ãã€‚<br>
                å¥³ç¥ã®å…µå™¨ã‚’ç ´å£Šã—ã€å†ã³é­”ç•Œã®å¹³å’Œã‚’å–ã‚Šæˆ»ã›ï¼<br><br>
                [â†â†‘â†“â†’] ç§»å‹• [SPACE] çµ†é–‹æ”¾ãƒ»ä¸€æ–‰æ”»æ’ƒ<br>
                [F] å¿…æ®ºæŠ€ï¼ˆãƒãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã®ã¿ã€6äººå…¨å“¡ãƒªãƒ³ã‚¯æ™‚ã€å…¨å¼¾å¹•ç ´å£Š+å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸ã€ä½¿ç”¨å›æ•°5å›ï¼‰
            </div>

            <div class="story-text" style="margin-top: 10px; max-width: min(700px, 90vw); font-size: clamp(10px, 1.8vw, 12px);">
                <strong style="color: #C5A9FF;">ä»²é–“ã®èƒ½åŠ›ï¼š</strong><br>
                <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; margin-top: 10px;">
                    <div style="text-align: center;">
                        <img src="picture/sol1_nom.png" style="width: min(32px, 6vw); height: min(32px, 6vw); image-rendering: pixelated;" alt="Warrior">
                        <div style="color: #FFE7FF; font-size: clamp(9px, 1.5vw, 11px);">Warrior<br>æ”»æ’ƒ+20%</div>
                    </div>
                    <div style="text-align: center;">
                        <img src="picture/sol2_nom.png" style="width: min(32px, 6vw); height: min(32px, 6vw); image-rendering: pixelated;" alt="Healer">
                        <div style="color: #A0FFA0; font-size: clamp(9px, 1.5vw, 11px);">Healer<br>å›å¾©/ç§’</div>
                    </div>
                    <div style="text-align: center;">
                        <img src="picture/sol3_nom.png" style="width: min(32px, 6vw); height: min(32px, 6vw); image-rendering: pixelated;" alt="Tank">
                        <div style="color: #FFA0A0; font-size: clamp(9px, 1.5vw, 11px);">Tank<br>é˜²å¾¡+15%</div>
                    </div>
                    <div style="text-align: center;">
                        <img src="picture/sol4_nom.png" style="width: min(32px, 6vw); height: min(32px, 6vw); image-rendering: pixelated;" alt="Speed">
                        <div style="color: #A0A0FF; font-size: clamp(9px, 1.5vw, 11px);">Speed<br>é€Ÿåº¦+30%</div>
                    </div>
                    <div style="text-align: center;">
                        <img src="picture/sol5_nom.png" style="width: min(32px, 6vw); height: min(32px, 6vw); image-rendering: pixelated;" alt="Mage">
                        <div style="color: #FFA0FF; font-size: clamp(9px, 1.5vw, 11px);">Mage<br>æ”»æ’ƒé »åº¦+</div>
                    </div>
                    <div style="text-align: center;">
                        <img src="picture/sol6_nom.png" style="width: min(32px, 6vw); height: min(32px, 6vw); image-rendering: pixelated;" alt="Guard">
                        <div style="color: #FFFFA0; font-size: clamp(9px, 1.5vw, 11px);">Guard<br>è»½æ¸›20%</div>
                    </div>
                </div>
                <div style="margin-top: 10px; font-size: clamp(9px, 1.5vw, 11px); color: #FFE7FF;">
                    â€»ãƒªãƒ³ã‚¯æ™‚ã®ã¿ä»²é–“ã¯ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã¾ã™
                </div>
            </div>

            <div class="btn-container" style="margin-top: 10px; pointer-events: auto; z-index: 100;">
                <button class="game-btn" onclick="game.showHelp()" style="pointer-events: auto;">éŠã³æ–¹ãƒ»è©³ç´°</button>
                <button id="soundToggleTitle" class="game-btn" style="width: 80px; height: 50px; font-size: 14px; min-width: 80px; min-height: 50px; background: linear-gradient(180deg, #666 0%, #333 100%); pointer-events: auto; z-index: 101;">ğŸ”Š ON</button>
            </div>
            
            <div style="margin-top: 15px; margin-bottom: 20px; display: flex; flex-direction: column; gap: 10px; align-items: center;">
                <div style="color: #C5A9FF; font-size: clamp(12px, 2vw, 14px); margin-bottom: 5px;">é›£æ˜“åº¦é¸æŠ</div>
                <div class="btn-container">
                    <button class="game-btn" onclick="game.setDifficulty('normal'); game.start();" style="width: min(140px, 25vw); min-width: 100px;">NORMAL</button>
                    <button class="game-btn" onclick="game.setDifficulty('hard'); game.start();" style="width: min(140px, 25vw); min-width: 100px; background: linear-gradient(180deg, #FF6B6B 0%, #CC0000 100%);">HARD</button>
                </div>
            </div>
        </div>

        <!-- Help Screen -->
        <div id="helpScreen" class="screen hidden">
            <div style="font-size: clamp(20px, 4vw, 32px); margin-bottom: 15px; margin-top: 10px; font-weight: bold; color: #C5A9FF;">éŠã³æ–¹ãƒ»ä»²é–“ã®èƒ½åŠ›</div>
            
            <div class="story-text" style="max-width: min(750px, 90vw); text-align: left; font-size: clamp(11px, 2vw, 13px);">
                <strong style="color: #C5A9FF; font-size: 16px;">æ“ä½œæ–¹æ³•</strong><br>
                [â†â†‘â†“â†’] ã¾ãŸã¯ [WASD] - ãƒ¬ã‚ªãƒ³ã‚’ç§»å‹•<br>
                [SPACE] - çµ†é–‹æ”¾æ”»æ’ƒï¼ˆãƒªãƒ³ã‚¯ã—ã¦ã„ã‚‹ä»²é–“ã‹ã‚‰ãƒœã‚¹ã¸ãƒ“ãƒ¼ãƒ ç™ºå°„ã€æœ€å¤§3æœ¬ï¼‰<br>
                [F] - å¿…æ®ºæŠ€ï¼šå…¨å¼¾å¹•ç ´å£Š+å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆãƒãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã®ã¿ã€6äººå…¨å“¡ãƒªãƒ³ã‚¯æ™‚ã®ã¿ä½¿ç”¨å¯èƒ½ã€ä½¿ç”¨å›æ•°5å›ï¼‰<br>
                [éŸ³ãƒœã‚¿ãƒ³] - å³ä¸Šã®ãƒœã‚¿ãƒ³ã§BGMã®ON/OFFåˆ‡ã‚Šæ›¿ãˆ<br><br>
                
                <strong style="color: #C5A9FF; font-size: 16px;">é›£æ˜“åº¦ãƒ¢ãƒ¼ãƒ‰</strong><br>
                <div style="margin-top: 10px; padding: 10px; background: rgba(200, 200, 255, 0.2); border-radius: 5px;">
                    <strong style="color: #A0A0FF;">NORMAL</strong> - æ¨™æº–çš„ãªé›£æ˜“åº¦ï¼ˆæ•µã®ä½“åŠ›ï¼š20000ï¼‰<br>
                    <strong style="color: #FF6B6B;">HARD</strong> - é«˜é›£æ˜“åº¦ï¼ˆæ•µã®ä½“åŠ›ï¼š160000ã€å¿…æ®ºæŠ€ä½¿ç”¨å¯èƒ½ã€ä½¿ç”¨å›æ•°5å›ï¼‰<br>
                    <div style="margin-top: 8px; font-size: 12px; color: #FFE7FF;">
                        <strong>ãƒãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã®ç‰¹æ®Šæ©Ÿèƒ½ï¼š</strong><br>
                        â€¢ å¿…æ®ºæŠ€ãŒ0ã®çŠ¶æ…‹ã§ä»²é–“ãŒå€’ã‚Œã‚‹ã¨ã€å¿…æ®ºæŠ€ãŒ1å›å¾©ã—ã¾ã™ï¼ˆæœ€å¤§3å›ã¾ã§ï¼‰<br>
                        â€¢ 6äººå…¨å“¡ãƒªãƒ³ã‚¯ã—ã¦ã„ã‚‹çŠ¶æ…‹ã§ä»²é–“ãŒå€’ã‚Œã‚‹ã¨ã€ãã®ä»²é–“ãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¿‘ãã«å¾©å¸°ã—ã¾ã™
                    </div>
                </div><br>
                
                <strong style="color: #C5A9FF; font-size: 16px;">ã‚²ãƒ¼ãƒ ã®ç›®çš„</strong><br>
                åˆ¶é™æ™‚é–“å†…ã«ä»²é–“ã¨ãƒªãƒ³ã‚¯ï¼ˆ150pxä»¥å†…ã§è‡ªå‹•ãƒªãƒ³ã‚¯ï¼‰ã—ã€ãƒœã‚¹ã‚’æ’ƒç ´ã›ã‚ˆï¼<br>
                ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®HPãŒ0ã«ãªã‚‹ã¨æ•—åŒ—ã§ã™ã€‚<br><br>
                
                <strong style="color: #C5A9FF; font-size: 16px;">ä»²é–“ã®èƒ½åŠ›ï¼ˆãƒªãƒ³ã‚¯æ™‚ã«ç™ºå‹•ï¼‰</strong><br>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 10px;">
                    <div style="display: flex; align-items: center; gap: 10px; padding: 10px; background: rgba(255, 255, 255, 0.1); border-radius: 5px;">
                        <img src="picture/sol1_nom.png" style="width: 48px; height: 48px; image-rendering: pixelated;" alt="Warrior">
                        <div>
                            <strong style="color: #FFE7FF;">Warrior</strong><br>
                            æ”»æ’ƒåŠ›+20%<br>
                            <span style="font-size: 11px; color: #aaa;">ãƒªãƒ³ã‚¯æ™‚ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ”»æ’ƒåŠ›ãŒä¸Šæ˜‡</span>
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px; padding: 10px; background: rgba(255, 255, 255, 0.1); border-radius: 5px;">
                        <img src="picture/sol2_nom.png" style="width: 48px; height: 48px; image-rendering: pixelated;" alt="Healer">
                        <div>
                            <strong style="color: #A0FFA0;">Healer</strong><br>
                            æ¯ç§’2HPå›å¾©<br>
                            <span style="font-size: 11px; color: #aaa;">ãƒªãƒ³ã‚¯æ™‚ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è‡ªå‹•å›å¾©</span>
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px; padding: 10px; background: rgba(255, 255, 255, 0.1); border-radius: 5px;">
                        <img src="picture/sol3_nom.png" style="width: 48px; height: 48px; image-rendering: pixelated;" alt="Tank">
                        <div>
                            <strong style="color: #FFA0A0;">Tank</strong><br>
                            é˜²å¾¡åŠ›+15%<br>
                            <span style="font-size: 11px; color: #aaa;">ãƒªãƒ³ã‚¯æ™‚ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é˜²å¾¡åŠ›ãŒä¸Šæ˜‡</span>
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px; padding: 10px; background: rgba(255, 255, 255, 0.1); border-radius: 5px;">
                        <img src="picture/sol4_nom.png" style="width: 48px; height: 48px; image-rendering: pixelated;" alt="Speed">
                        <div>
                            <strong style="color: #A0A0FF;">Speed</strong><br>
                            ç§»å‹•é€Ÿåº¦+30%<br>
                            <span style="font-size: 11px; color: #aaa;">ãƒªãƒ³ã‚¯æ™‚ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•é€Ÿåº¦ãŒä¸Šæ˜‡</span>
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px; padding: 10px; background: rgba(255, 255, 255, 0.1); border-radius: 5px;">
                        <img src="picture/sol5_nom.png" style="width: 48px; height: 48px; image-rendering: pixelated;" alt="Mage">
                        <div>
                            <strong style="color: #FFA0FF;">Mage</strong><br>
                            æ”»æ’ƒé »åº¦+30%<br>
                            <span style="font-size: 11px; color: #aaa;">ãƒªãƒ³ã‚¯æ™‚ã«çµ†é–‹æ”¾æ”»æ’ƒã®é–“éš”ãŒçŸ­ç¸®</span>
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px; padding: 10px; background: rgba(255, 255, 255, 0.1); border-radius: 5px;">
                        <img src="picture/sol6_nom.png" style="width: 48px; height: 48px; image-rendering: pixelated;" alt="Guard">
                        <div>
                            <strong style="color: #FFFFA0;">Guard</strong><br>
                            ãƒ€ãƒ¡ãƒ¼ã‚¸20%è»½æ¸›<br>
                            <span style="font-size: 11px; color: #aaa;">ãƒªãƒ³ã‚¯æ™‚ã«å—ã‘ã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è»½æ¸›</span>
                        </div>
                    </div>
                </div>
                <div style="margin-top: 15px; padding: 10px; background: rgba(255, 200, 100, 0.2); border-radius: 5px; border: 1px solid rgba(255, 200, 100, 0.5);">
                    <strong style="color: #FFE7FF;">âš  é‡è¦ãªæ³¨æ„äº‹é …</strong><br>
                    â€¢ ãƒªãƒ³ã‚¯ã—ã¦ã„ã‚‹ä»²é–“ã®ã¿ã€æ•µã®æ”»æ’ƒã§ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã¾ã™<br>
                    â€¢ ãƒªãƒ³ã‚¯ã—ã¦ã„ãªã„ä»²é–“ã¯ç„¡æ•µã§ã™<br>
                    â€¢ åŒã˜ã‚¿ã‚¤ãƒ—ã®ä»²é–“ã¯ä¸€åº¦ã«1äººã¾ã§å‡ºç¾ã—ã¾ã™<br>
                    â€¢ æœ€å¤§6äººã¾ã§ä»²é–“ã¨ãƒªãƒ³ã‚¯ã§ãã¾ã™<br>
                    â€¢ ãƒãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€6äººå…¨å“¡ãƒªãƒ³ã‚¯æ™‚ã«[F]ã‚­ãƒ¼ã§å¿…æ®ºæŠ€ãŒä½¿ç”¨ã§ãã¾ã™ï¼ˆå…¨å¼¾å¹•ç ´å£Š+å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸ã€ä½¿ç”¨å›æ•°5å›ï¼‰<br>
                    â€¢ <strong style="color: #FFD700;">å¿…æ®ºæŠ€ã®å›å¾©ï¼š</strong>ãƒãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã§å¿…æ®ºæŠ€ãŒ0ã®çŠ¶æ…‹ã§ä»²é–“ãŒå€’ã‚Œã‚‹ã¨ã€å¿…æ®ºæŠ€ãŒ1å›å¾©ã—ã¾ã™ï¼ˆæœ€å¤§3å›ã¾ã§ï¼‰<br>
                    â€¢ <strong style="color: #FFD700;">ä»²é–“ã®å¾©å¸°ï¼š</strong>ãƒãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã§6äººå…¨å“¡ãƒªãƒ³ã‚¯ã—ã¦ã„ã‚‹çŠ¶æ…‹ã§ä»²é–“ãŒå€’ã‚Œã‚‹ã¨ã€ãã®ä»²é–“ãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¿‘ãï¼ˆ100-200pxã®ç¯„å›²ï¼‰ã«å¾©å¸°ã—ã¾ã™ã€‚å¾©å¸°ã—ãŸä»²é–“ã¯å†ãƒªãƒ³ã‚¯ãŒå¿…è¦ã§ã™
                </div>
            </div>
            
            <button class="game-btn" onclick="game.init()" style="margin-top: 20px;">ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹</button>
        </div>

        <!-- Result Screen -->
        <div id="resultScreen" class="screen hidden">
            <div id="resultTitle" style="font-size: 40px; margin-bottom: 20px; font-weight: bold;">RESULT</div>
            <div id="resultStats" class="story-text">
                <!-- JS Populated -->
            </div>
            <div class="btn-container">
                <button class="game-btn" onclick="game.init()">TITLE</button>
                <button class="game-btn" onclick="game.start()">RETRY</button>
            </div>
        </div>
    </div>

    <script>
        /**
         * Game Configuration & Asset Manifest
         */
        const ASSETS = {
            images: {
                player: 'picture/leon_player.png',
                logo: 'picture/title_logo.png',
                background: 'picture/background.png',
                enemy: 'picture/enemy.png',
                explosion: 'picture/explosion.png',
                beam_straight: 'picture/Straight_beam.png',
                beam_spread: 'picture/Spread_beam.png',
                beam_homing: 'picture/Homing_beam.png',
                frame1: 'picture/Frame1.png',
                bond_link: 'picture/Bond_Effect_link.png',
                bond_dam: 'picture/Bond_Effect_dam.png',

                // Allies (Normal, Link, Damage)
                sol1_n: 'picture/sol1_nom.png', sol1_l: 'picture/sol1_link.png', sol1_d: 'picture/sol1_dam.png',
                sol2_n: 'picture/sol2_nom.png', sol2_l: 'picture/sol2_link.png', sol2_d: 'picture/sol2_dam.png',
                sol3_n: 'picture/sol3_nom.png', sol3_l: 'picture/sol3_link.png', sol3_d: 'picture/sol3_dam.png',
                sol4_n: 'picture/sol4_nom.png', sol4_l: 'picture/sol4_link.png', sol4_d: 'picture/sol4_dam.png',
                sol5_n: 'picture/sol5_nom.png', sol5_l: 'picture/sol5_link.png', sol5_d: 'picture/sol5_dam.png',
                sol6_n: 'picture/sol6_nom.png', sol6_l: 'picture/sol6_link.png', sol6_d: 'picture/sol6_dam.png',
            }
        };

        const ALLY_TYPES = [
            { 
                id: 1, 
                name: 'Warrior', 
                hp: 30, 
                speed: 1.0, 
                type: 'warrior',
                ability: 'attack', // æ”»æ’ƒåŠ›ã‚¢ãƒƒãƒ—
                abilityValue: 0.2 // æ”»æ’ƒåŠ›+20%
            },
            { 
                id: 2, 
                name: 'Healer', 
                hp: 25, 
                speed: 0.9, 
                type: 'healer',
                ability: 'heal', // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å›å¾©
                abilityValue: 2, // æ¯ç§’2HPå›å¾©
                healCooldown: 0
            },
            { 
                id: 3, 
                name: 'Tank', 
                hp: 40, 
                speed: 0.8, 
                type: 'tank',
                ability: 'defense', // é˜²å¾¡åŠ›ã‚¢ãƒƒãƒ—
                abilityValue: 0.15 // é˜²å¾¡åŠ›+15%
            },
            { 
                id: 4, 
                name: 'Speed', 
                hp: 25, 
                speed: 1.2, 
                type: 'speed',
                ability: 'speed', // ç§»å‹•é€Ÿåº¦ã‚¢ãƒƒãƒ—
                abilityValue: 0.3 // ç§»å‹•é€Ÿåº¦+30%
            },
            { 
                id: 5, 
                name: 'Mage', 
                hp: 25, 
                speed: 0.9, 
                type: 'mage',
                ability: 'attackSpeed', // æ”»æ’ƒé »åº¦ã‚¢ãƒƒãƒ—ï¼ˆä»²é–“ã®æ•°ã«å¿œã˜ã¦çŸ­ç¸®ï¼‰
                abilityValue: 0.3 // æœ€å¤§30%çŸ­ç¸®ï¼ˆä»²é–“ã®æ•°ã«å¿œã˜ã¦å¤‰åŒ–ï¼‰
            },
            { 
                id: 6, 
                name: 'Guard', 
                hp: 35, 
                speed: 0.9, 
                type: 'guard',
                ability: 'shield', // ã‚·ãƒ¼ãƒ«ãƒ‰ï¼ˆãƒ€ãƒ¡ãƒ¼ã‚¸è»½æ¸›ï¼‰
                abilityValue: 0.2 // ãƒ€ãƒ¡ãƒ¼ã‚¸20%è»½æ¸›
            }
        ];

        /**
         * Asset Loader
         */
        class AssetLoader {
            constructor() {
                this.images = {};
                this.loadedCount = 0;
                this.totalCount = 0;
            }

            async loadAll(onProgress) {
                const imageKeys = Object.keys(ASSETS.images);
                this.totalCount = imageKeys.length;

                const promises = imageKeys.map(key => {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.src = ASSETS.images[key];
                        img.onload = () => {
                            this.images[key] = img;
                            this.loadedCount++;
                            if (onProgress) onProgress(this.loadedCount / this.totalCount);
                            resolve();
                        };
                        img.onerror = () => {
                            console.error(`Failed to load ${ASSETS.images[key]}`);
                            // Resolve anyway to not block game, but might show broken image
                            this.images[key] = null;
                            this.loadedCount++;
                            resolve();
                        };
                    });
                });

                await Promise.all(promises);
                return this.images;
            }

            get(key) {
                return this.images[key];
            }
        }

        /**
         * Game Engine & Logic
         */
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.baseWidth = 1200;  // åŸºæº–å¹…
                this.baseHeight = 800;  // åŸºæº–é«˜ã•
                this.width = this.baseWidth;
                this.height = this.baseHeight;
                this.scaleX = 1.0;  // åˆæœŸã‚¹ã‚±ãƒ¼ãƒ«
                this.scaleY = 1.0;  // åˆæœŸã‚¹ã‚±ãƒ¼ãƒ«
                
                // ç”»é¢ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦ãƒªã‚µã‚¤ã‚º
                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.assets = new AssetLoader();
                this.state = 'loading'; // loading, title, playing, gameover, victory

                this.lastTime = 0;
                this.frameId = null;

                // Game Objects
                this.player = null;
                this.allies = [];
                this.boss = null;
                this.bullets = [];
                this.effects = [];

                // Stats
                this.score = 0;
                this.time = 180;
                this.keys = {};
                this.attackCooldown = 0; // çµ†é–‹æ”¾æ”»æ’ƒã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
                this.baseAttackCooldown = 1.5; // åŸºæœ¬æ”»æ’ƒé–“éš”ï¼ˆç§’ï¼‰
                this.difficulty = 'normal'; // é›£æ˜“åº¦ï¼š'normal' ã¾ãŸã¯ 'hard'
                this.specialAttackUses = 5; // å¿…æ®ºæŠ€ã®ä½¿ç”¨å›æ•°ï¼ˆæœ€å¤§5å›ï¼‰
                
                // Audio
                this.bgm = null;
                this.currentBgm = null;
                this.soundEnabled = true; // éŸ³ã®ON/OFFçŠ¶æ…‹

                // Inputs
                window.addEventListener('keydown', e => {
                    this.keys[e.key] = true;
                    // çµ†é–‹æ”¾æ”»æ’ƒï¼ˆã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ï¼‰
                    if (e.key === ' ' && this.state === 'playing') {
                        e.preventDefault();
                        this.activateBond();
                    }
                    // å¿…æ®ºæŠ€ï¼ˆFã‚­ãƒ¼ã€ãƒãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã®ã¿ã€6äººå…¨å“¡ãƒªãƒ³ã‚¯æ™‚ï¼‰
                    if ((e.key === 'f' || e.key === 'F') && this.state === 'playing') {
                        e.preventDefault();
                        this.activateSpecialAttack();
                    }
                    // çµ‚äº†ç”»é¢ã§ã¯ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã‚’ç„¡åŠ¹åŒ–ï¼ˆç”»é¢é·ç§»ã‚’é˜²ãï¼‰
                    if (e.key === ' ' && (this.state === 'victory' || this.state === 'gameover')) {
                        e.preventDefault();
                    }
                });
                window.addEventListener('keyup', e => this.keys[e.key] = false);

                // Load Assets
                this.assets.loadAll(progress => {
                    document.getElementById('loadProg').style.width = (progress * 100) + '%';
                }).then(() => {
                    document.getElementById('loadingScreen').classList.add('hidden');
                    this.init();
                });
                
                // éŸ³ã®ON/OFFãƒœã‚¿ãƒ³ï¼ˆã‚²ãƒ¼ãƒ ä¸­ï¼‰
                const soundToggle = document.getElementById('soundToggle');
                if (soundToggle) {
                    soundToggle.addEventListener('click', () => {
                        this.toggleSound();
                    });
                }
                
                // éŸ³ã®ON/OFFãƒœã‚¿ãƒ³ï¼ˆã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ï¼‰
                const soundToggleTitle = document.getElementById('soundToggleTitle');
                if (soundToggleTitle) {
                    soundToggleTitle.addEventListener('click', () => {
                        this.toggleSound();
                    });
                }
            }
            
            toggleSound() {
                this.soundEnabled = !this.soundEnabled;
                const soundToggle = document.getElementById('soundToggle');
                const soundToggleTitle = document.getElementById('soundToggleTitle');
                const buttonText = this.soundEnabled ? 'ğŸ”Š ON' : 'ğŸ”‡ OFF';
                
                if (soundToggle) soundToggle.innerText = buttonText;
                if (soundToggleTitle) soundToggleTitle.innerText = buttonText;
                
                if (!this.soundEnabled) {
                    // éŸ³ã‚’OFFã«ã™ã‚‹
                    if (this.bgm) {
                        this.bgm.pause();
                    }
                } else {
                    // éŸ³ã‚’ONã«ã™ã‚‹ï¼ˆã‚²ãƒ¼ãƒ ä¸­ãªã‚‰BGMã‚’å†é–‹ï¼‰
                    if (this.state === 'playing' && this.bgm) {
                        this.bgm.play().catch(e => {
                            console.log('BGMå†é–‹ã‚¨ãƒ©ãƒ¼:', e);
                        });
                    }
                }
            }

            resize() {
                const container = document.getElementById('gameContainer');
                const containerRect = container.getBoundingClientRect();
                
                // ã‚³ãƒ³ãƒ†ãƒŠã®å®Ÿéš›ã®ã‚µã‚¤ã‚ºã‚’å–å¾—
                const containerWidth = containerRect.width;
                const containerHeight = containerRect.height;
                
                // Canvasã®ã‚µã‚¤ã‚ºã‚’ã‚³ãƒ³ãƒ†ãƒŠã«åˆã‚ã›ã‚‹
                this.canvas.width = containerWidth;
                this.canvas.height = containerHeight;
                
                // ã‚²ãƒ¼ãƒ å†…ã®åº§æ¨™è¨ˆç®—ç”¨ã®ã‚µã‚¤ã‚ºã‚’æ›´æ–°
                this.width = containerWidth;
                this.height = containerHeight;
                
                // ã‚¹ã‚±ãƒ¼ãƒ«æ¯”ã‚’è¨ˆç®—ï¼ˆåŸºæº–ã‚µã‚¤ã‚ºã¨ã®æ¯”ç‡ï¼‰
                this.scaleX = containerWidth / this.baseWidth;
                this.scaleY = containerHeight / this.baseHeight;
                
                // ã‚²ãƒ¼ãƒ ä¸­ãªã‚‰å†æç”»
                if (this.state === 'playing') {
                    this.render();
                }
            }

            init() {
                this.state = 'title';
                this.gameStartTime = null; // ãƒªã‚»ãƒƒãƒˆ
                document.getElementById('titleScreen').classList.remove('hidden');
                document.getElementById('resultScreen').classList.add('hidden');
                document.getElementById('helpScreen').classList.add('hidden');

                // Draw background for title
                this.ctx.clearRect(0, 0, this.width, this.height);
                this.ctx.save();
                this.ctx.scale(this.scaleX, this.scaleY);
                const bg = this.assets.get('background');
                if (bg) this.ctx.drawImage(bg, 0, 0, this.baseWidth, this.baseHeight);
                this.ctx.restore();
                
                // BGMåœæ­¢
                this.stopBGM();
            }

            showHelp() {
                document.getElementById('titleScreen').classList.add('hidden');
                document.getElementById('helpScreen').classList.remove('hidden');
            }

            setDifficulty(mode) {
                this.difficulty = mode; // 'normal' ã¾ãŸã¯ 'hard'
            }

            start() {
                this.state = 'playing';
                this.score = 0;
                this.time = 180;
                this.allies = [];
                this.bullets = [];
                this.effects = [];
                this.gameStartTime = performance.now(); // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚åˆ»ã‚’è¨˜éŒ²
                this.specialAttackUses = 5; // å¿…æ®ºæŠ€ã®ä½¿ç”¨å›æ•°ã‚’ãƒªã‚»ãƒƒãƒˆ

                this.player = new Player(this);
                this.boss = new Boss(this);

                // Initial Allies (æœ€å¤§6äººã¾ã§)
                for (let i = 0; i < 3; i++) this.spawnAlly();

                document.getElementById('titleScreen').classList.add('hidden');
                document.getElementById('resultScreen').classList.add('hidden');
                document.getElementById('helpScreen').classList.add('hidden');

                // BGMå†ç”Ÿ
                this.playBGM('music/çµ†ã®åˆƒ.mp3');

                this.lastTime = performance.now();
                this.loop(this.lastTime);
            }
            
            playBGM(src) {
                // æ—¢å­˜ã®BGMã‚’åœæ­¢
                this.stopBGM();
                
                // éŸ³ãŒOFFã®å ´åˆã¯å†ç”Ÿã—ãªã„
                if (!this.soundEnabled) return;
                
                // æ–°ã—ã„BGMã‚’å†ç”Ÿ
                this.bgm = new Audio(src);
                this.bgm.loop = true;
                this.bgm.volume = 0.5;
                this.currentBgm = src;
                
                // ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¨ãƒ«ãƒ¼ãƒ—ç¢ºå®ŸåŒ–
                this.bgm.addEventListener('ended', () => {
                    // ãƒ«ãƒ¼ãƒ—ãŒæ©Ÿèƒ½ã—ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                    if (this.bgm && this.state === 'playing' && this.soundEnabled) {
                        this.bgm.currentTime = 0;
                        this.bgm.play().catch(e => {
                            console.log('BGMå†é–‹ã‚¨ãƒ©ãƒ¼:', e);
                        });
                    }
                });
                
                this.bgm.addEventListener('error', (e) => {
                    console.log('BGMã‚¨ãƒ©ãƒ¼:', e);
                });
                
                this.bgm.play().catch(e => {
                    console.log('BGMå†ç”Ÿã‚¨ãƒ©ãƒ¼ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãŒå¿…è¦ãªå¯èƒ½æ€§ï¼‰:', e);
                });
            }
            
            stopBGM() {
                if (this.bgm) {
                    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
                    this.bgm.removeEventListener('ended', null);
                    this.bgm.removeEventListener('error', null);
                    this.bgm.pause();
                    this.bgm.currentTime = 0;
                    this.bgm = null;
                    this.currentBgm = null;
                }
            }

            spawnAlly() {
                if (this.allies.length >= 6) return; // æœ€å¤§6äººã¾ã§
                
                // æ—¢ã«å­˜åœ¨ã™ã‚‹ã‚¿ã‚¤ãƒ—ã‚’å–å¾—
                const existingTypes = this.allies.map(a => a.typeConf.id);
                
                // ã¾ã å‡ºç¾ã—ã¦ã„ãªã„ã‚¿ã‚¤ãƒ—ã‚’å–å¾—
                const availableTypes = ALLY_TYPES.filter(type => !existingTypes.includes(type.id));
                
                // å…¨ã¦ã®ã‚¿ã‚¤ãƒ—ãŒå‡ºç¾æ¸ˆã¿ã®å ´åˆã¯ãƒ©ãƒ³ãƒ€ãƒ é¸æŠ
                const type = availableTypes.length > 0 
                    ? availableTypes[Math.floor(Math.random() * availableTypes.length)]
                    : ALLY_TYPES[Math.floor(Math.random() * ALLY_TYPES.length)];
                
                // Random pos edgeï¼ˆåŸºæº–ã‚µã‚¤ã‚ºã§è¨ˆç®—ï¼‰
                let x, y;
                if (Math.random() < 0.5) {
                    x = Math.random() < 0.5 ? -20 : this.baseWidth + 20;
                    y = Math.random() * this.baseHeight;
                } else {
                    x = Math.random() * this.baseWidth;
                    y = Math.random() < 0.5 ? -20 : this.baseHeight + 20;
                }
                this.allies.push(new Ally(this, x, y, type));
            }

            loop(timestamp) {
                if (this.state !== 'playing') return;
                const dt = (timestamp - this.lastTime) / 1000;
                this.lastTime = timestamp;

                this.update(dt);
                this.render();

                requestAnimationFrame(t => this.loop(t));
            }

            update(dt) {
                // Time
                this.time -= dt;
                if (this.time <= 0) this.endGame(false);
                
                // æ”»æ’ƒã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’æ›´æ–°
                if (this.attackCooldown > 0) {
                    this.attackCooldown -= dt;
                }
                
                // BGMãŒåœæ­¢ã—ã¦ã„ãªã„ã‹ç¢ºèªï¼ˆã‚²ãƒ¼ãƒ ä¸­ã®ã¿ã€éŸ³ãŒONã®å ´åˆã®ã¿ï¼‰
                if (this.state === 'playing' && this.bgm && this.soundEnabled) {
                    if (this.bgm.paused && this.bgm.readyState >= 2) {
                        // ä¸€æ™‚åœæ­¢ã—ã¦ã„ã‚‹å ´åˆã¯å†é–‹
                        this.bgm.play().catch(e => {
                            // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãŒå¿…è¦ãªå ´åˆãªã©ï¼‰
                        });
                    }
                } else if (this.state === 'playing' && this.bgm && !this.soundEnabled) {
                    // éŸ³ãŒOFFã®å ´åˆã¯åœæ­¢
                    if (!this.bgm.paused) {
                        this.bgm.pause();
                    }
                }

                // Entities
                this.player.update(dt);
                this.boss.update(dt);
                this.allies.forEach((a, i) => {
                    a.update(dt);
                    // å€’ã‚ŒãŸä»²é–“ã‚’å‡¦ç†
                    if (a.dead) {
                        // å¿…æ®ºæŠ€ãŒ0ã®çŠ¶æ…‹ã§ä»²é–“ãŒå€’ã‚ŒãŸã‚‰å¿…æ®ºæŠ€ã‚’å›å¾©ï¼ˆãƒãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã®ã¿ï¼‰
                        if (this.difficulty === 'hard' && this.specialAttackUses <= 0) {
                            this.specialAttackUses = Math.min(5, this.specialAttackUses + 1);
                        }
                        
                        // ãƒãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã§6äººå…¨å“¡ãƒªãƒ³ã‚¯ã—ã¦ã„ã‚‹å ´åˆã€è¿‘ãã«å¾©å¸°
                        // å€’ã‚Œã‚‹å‰ã®ãƒªãƒ³ã‚¯æ•°ã‚’è¨ˆç®—ï¼ˆã“ã®ä»²é–“ã‚’å«ã‚€ï¼‰
                        const bondCountBefore = this.allies.filter(ally => ally.linked && !ally.dead).length;
                        const wasLinked = a.linked;
                        const deadAllyType = a.typeConf;
                        
                        this.allies.splice(i, 1);
                        
                        if (this.difficulty === 'hard' && bondCountBefore >= 6 && wasLinked) {
                            // ãƒãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã§6äººå…¨å“¡ãƒªãƒ³ã‚¯ã—ã¦ã„ãŸå ´åˆã€è¿‘ãã«å¾©å¸°
                            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘¨è¾ºï¼ˆ100-200pxã®ç¯„å›²ï¼‰ã«å¾©æ´»
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 100 + Math.random() * 100; // 100-200pxã®ç¯„å›²
                            const respawnX = Math.max(24, Math.min(this.baseWidth - 24, 
                                this.player.x + Math.cos(angle) * distance));
                            const respawnY = Math.max(104, Math.min(this.baseHeight - 24, 
                                this.player.y + Math.sin(angle) * distance)); // UIåˆ†80px + 24px
                            
                            // åŒã˜ã‚¿ã‚¤ãƒ—ã®ä»²é–“ã¨ã—ã¦å¾©æ´»ï¼ˆãƒªãƒ³ã‚¯çŠ¶æ…‹ã¯è§£é™¤ï¼‰
                            const respawnedAlly = new Ally(this, respawnX, respawnY, deadAllyType);
                            respawnedAlly.linked = false; // å¾©æ´»æ™‚ã¯ãƒªãƒ³ã‚¯ã—ã¦ã„ãªã„
                            respawnedAlly.relinkCooldown = 1.0; // 1ç§’ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
                            this.allies.push(respawnedAlly);
                            
                            // å¾©æ´»ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                            this.effects.push(new Effect(this, respawnX, respawnY, 'bond_link'));
                        } else {
                            // é€šå¸¸ã®å‡¦ç†ï¼šã™ãã«æ–°ã—ã„ä»²é–“ã‚’å‡ºç¾ã•ã›ã‚‹ï¼ˆæœ€å¤§6äººã¾ã§ï¼‰
                            if (this.allies.length < 6) {
                                this.spawnAlly();
                            }
                        }
                    }
                });
                this.bullets.forEach((b, i) => {
                    b.update(dt);
                    if (b.dead) this.bullets.splice(i, 1);
                });
                this.effects.forEach((e, i) => {
                    e.update(dt);
                    if (e.dead) this.effects.splice(i, 1);
                });

                // Spawn Allies Randomly (é©åº¦ãªé »åº¦ã§å‡ºç¾ã€æœ€å¤§6äººã¾ã§)
                // æ³¨ï¼šä»²é–“ãŒå€’ã‚ŒãŸæ™‚ã¯ä¸Šè¨˜ã®å‡¦ç†ã§å³åº§ã«å‡ºç¾ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯é€šå¸¸ã®å‡ºç¾ã®ã¿
                if (this.allies.length < 6 && Math.random() < 0.01) this.spawnAlly();

                // Check Victory/Defeat Conditions
                const bondCount = this.allies.filter(a => a.linked).length;
                
                // æ•—åŒ—æ¡ä»¶ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®HPãŒ0ã«ãªã£ãŸå ´åˆï¼ˆãƒœã‚¹ã‹ã‚‰æ”»æ’ƒã‚’å—ã‘ã¦ï¼‰
                if (this.player.hp <= 0 || this.player.dead) {
                    this.endGame(false);
                    return;
                }
                
                // å‹åˆ©æ¡ä»¶ï¼šçµ†ã‚²ãƒ¼ã‚¸100%åˆ°é”ã§æ•µæ’ƒç ´ï¼ˆ6äººå…¨å“¡ãƒªãƒ³ã‚¯ï¼‰
                if (bondCount >= 6 && this.boss.hp <= 0 && this.boss.dead) {
                    this.endGame(true);
                    return;
                }
                
                // ãƒœã‚¹æ’ƒç ´ã®ã¿ã§ã‚‚å‹åˆ©ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
                if (this.boss.hp <= 0 && this.boss.dead) {
                    this.endGame(true);
                    return;
                }

                // UI Update
                document.getElementById('scoreVal').innerText = Math.floor(this.score);
                document.getElementById('bondCount').innerText = bondCount;
                document.getElementById('bondBar').style.width = ((bondCount / 6) * 100) + '%'; // æœ€å¤§6äºº
                document.getElementById('playerHp').innerText = Math.max(0, Math.floor(this.player.hp));

                const m = Math.floor(this.time / 60);
                const s = Math.floor(this.time % 60).toString().padStart(2, '0');
                const timerEl = document.getElementById('timerVal');
                timerEl.innerText = `${m}:${s}`;
                if (this.time <= 30) document.getElementById('timerBox').classList.add('warning');
                else document.getElementById('timerBox').classList.remove('warning');
                
                // å¿…æ®ºæŠ€ã®UIè¡¨ç¤ºï¼ˆãƒãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã®ã¿ï¼‰
                const specialAttackInfo = document.getElementById('specialAttackInfo');
                const specialAttackUses = document.getElementById('specialAttackUses');
                if (this.difficulty === 'hard') {
                    specialAttackInfo.style.display = 'block';
                    specialAttackUses.innerText = this.specialAttackUses;
                    if (this.specialAttackUses <= 0) {
                        specialAttackInfo.style.color = '#888';
                    } else if (bondCount === 6) {
                        specialAttackInfo.style.color = '#FFD700';
                    } else {
                        specialAttackInfo.style.color = '#888';
                    }
                } else {
                    specialAttackInfo.style.display = 'none';
                }
            }

            render() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’é©ç”¨ã—ã¦æç”»
                this.ctx.save();
                this.ctx.scale(this.scaleX, this.scaleY);

                // Background
                const bg = this.assets.get('background');
                if (bg) this.ctx.drawImage(bg, 0, 0, this.baseWidth, this.baseHeight);

                // Links (draw before allies) - Canvasæç”»ã§ç”»åƒã‚’ä½¿ã‚ãªã„
                this.allies.forEach(a => {
                    if (a.linked) {
                        // Draw Link Line with gradient effect
                        const gradient = this.ctx.createLinearGradient(
                            this.player.x, this.player.y,
                            a.x, a.y
                        );
                        gradient.addColorStop(0, '#FFE7FF'); // ä¸­å¿ƒï¼ˆç™½ã«è¿‘ã„ï¼‰
                        gradient.addColorStop(0.5, '#C5A9FF'); // ä¸­é–“ï¼ˆè–„ç´«ï¼‰
                        gradient.addColorStop(1, '#5544DD'); // ç«¯ï¼ˆæ¿ƒã„ç´«ï¼‰
                        
                        this.ctx.strokeStyle = gradient;
                        this.ctx.lineWidth = 3;
                        this.ctx.lineCap = 'round';
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = '#C5A9FF';
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.player.x, this.player.y);
                        this.ctx.lineTo(a.x, a.y);
                        this.ctx.stroke();
                        this.ctx.shadowBlur = 0;
                    }
                });

                this.boss.render(this.ctx);
                this.allies.forEach(a => a.render(this.ctx));
                this.player.render(this.ctx);
                this.bullets.forEach(b => b.render(this.ctx));
                this.effects.forEach(e => e.render(this.ctx));
                
                this.ctx.restore();
            }

            activateSpecialAttack() {
                // ãƒãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã®ã¿
                if (this.difficulty !== 'hard') return;
                
                // ä½¿ç”¨å›æ•°ãƒã‚§ãƒƒã‚¯
                if (this.specialAttackUses <= 0) return;
                
                // 6äººå…¨å“¡ãŒãƒªãƒ³ã‚¯ã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                const linked = this.allies.filter(a => a.linked);
                if (linked.length < 6) return;
                
                // å¿…æ®ºæŠ€ç™ºå‹•ï¼šå…¨ã¦ã®å¼¾å¹•ã‚’ç ´å£Š + ãƒœã‚¹ã«ãƒ€ãƒ¡ãƒ¼ã‚¸
                this.specialAttackUses--;
                
                // å…¨ã¦ã®å¼¾å¹•ã‚’ç ´å£Š
                this.bullets.forEach(bullet => {
                    // ç ´å£Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¿½åŠ 
                    this.effects.push(new Effect(this, bullet.x, bullet.y, 'explosion'));
                    bullet.dead = true;
                });
                
                // ãƒœã‚¹ã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ï¼ˆ6äººå…¨å“¡ãƒªãƒ³ã‚¯æ™‚ã®çµ†é–‹æ”¾æ”»æ’ƒã®3å€ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰
                const baseDamage = 6 * 50; // 6äººåˆ†ã®åŸºæœ¬ãƒ€ãƒ¡ãƒ¼ã‚¸
                const damage = baseDamage * this.player.attackMultiplier * 3; // 3å€ã®ãƒ€ãƒ¡ãƒ¼ã‚¸
                this.boss.takeDamage(damage);
                
                // ãƒœã‚¹ã¸ã®ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                this.createBossHitEffect(this.boss.x, this.boss.y);
                
                // ç”»é¢å…¨ä½“ã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¿½åŠ 
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * this.width;
                    const y = Math.random() * this.height;
                    this.effects.push(new Effect(this, x, y, 'explosion'));
                }
                
                // ã‚¹ã‚³ã‚¢ãƒœãƒ¼ãƒŠã‚¹
                this.score += 500;
            }

            activateBond() {
                const linked = this.allies.filter(a => a.linked);
                if (linked.length === 0) return;
                
                // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ã¯æ”»æ’ƒã§ããªã„
                if (this.attackCooldown > 0) return;
                
                // æ”»æ’ƒé–“éš”ã‚’è¨ˆç®—ï¼ˆMageãŒãƒªãƒ³ã‚¯ã—ã¦ã„ã‚‹å ´åˆã€ä»²é–“ã®æ•°ã«å¿œã˜ã¦çŸ­ç¸®ï¼‰
                let attackInterval = this.baseAttackCooldown;
                const mageLinked = linked.some(a => a.ability === 'attackSpeed');
                
                if (mageLinked) {
                    // MageãŒãƒªãƒ³ã‚¯ã—ã¦ã„ã‚‹å ´åˆã€ä»²é–“ã®æ•°ã«å¿œã˜ã¦çŸ­ç¸®
                    // 1äººï¼š1.0ç§’ã€3äººï¼š0.5ç§’ã€6äººï¼š0.1ç§’
                    const count = linked.length;
                    if (count >= 6) {
                        attackInterval = 0.1;
                    } else if (count >= 3) {
                        // 3äººã‹ã‚‰6äººã¾ã§ç·šå½¢è£œé–“
                        const t = (count - 3) / 3; // 0 (3äºº) ã‹ã‚‰ 1 (6äºº)
                        attackInterval = 0.5 - (0.5 - 0.1) * t;
                    } else if (count >= 1) {
                        // 1äººã‹ã‚‰3äººã¾ã§ç·šå½¢è£œé–“
                        const t = (count - 1) / 2; // 0 (1äºº) ã‹ã‚‰ 1 (3äºº)
                        attackInterval = 1.0 - (1.0 - 0.5) * t;
                    } else {
                        attackInterval = this.baseAttackCooldown;
                    }
                }
                
                this.attackCooldown = attackInterval;

                // å¼¾ã¯ç ´å£Šã—ãªã„ï¼ˆæ•µã®æ”»æ’ƒã¯ãã®ã¾ã¾æ®‹ã‚‹ï¼‰

                // Damage Boss (çµ†ã®æ•°ã«å¿œã˜ã¦æ”»æ’ƒåŠ›ãŒå¢—åŠ ï¼š1äººã‚ãŸã‚Š+10%)
                const baseDamage = linked.length * 50;
                const damage = baseDamage * this.player.attackMultiplier;
                this.boss.takeDamage(damage);

                // Visuals - æœ€å¤§3æœ¬ã®ãƒ“ãƒ¼ãƒ ï¼ˆç”»åƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆãªã—ï¼‰
                const maxBeams = 3;
                const beamsToCreate = Math.min(linked.length, maxBeams);
                for (let i = 0; i < beamsToCreate; i++) {
                    const ally = linked[i];
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®çµ†é–‹æ”¾æ”»æ’ƒï¼šä»²é–“ã‹ã‚‰ãƒœã‚¹ã¸å‘ã‹ã†å…‰ã®ãƒ“ãƒ¼ãƒ 
                    this.createBondAttackBeam(ally.x, ally.y, this.boss.x, this.boss.y);
                }
                // ãƒœã‚¹ã¸ã®Canvasæç”»ã®çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆç”»åƒãªã—ï¼‰
                this.createBossHitEffect(this.boss.x, this.boss.y);

                this.score += Math.floor(damage);
            }

            createBondAttackBeam(fromX, fromY, toX, toY) {
                // çµ†é–‹æ”¾æ”»æ’ƒã®ãƒ“ãƒ¼ãƒ ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¿½åŠ 
                const beam = new BondAttackBeam(this, fromX, fromY, toX, toY);
                this.effects.push(beam);
            }

            createBossHitEffect(x, y) {
                // ãƒœã‚¹ã¸ã®ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆCanvasæç”»ã€ç”»åƒãªã—ï¼‰
                const hitEffect = new BossHitEffect(this, x, y);
                this.effects.push(hitEffect);
            }

            endGame(victory) {
                this.state = victory ? 'victory' : 'gameover';
                const scr = document.getElementById('resultScreen');
                scr.classList.remove('hidden');

                const title = document.getElementById('resultTitle');
                title.innerText = victory ? "MISSION COMPLETE" : "MISSION FAILED";
                title.style.color = victory ? "#FFE7FF" : "#ff4444";

                const stats = document.getElementById('resultStats');
                const bondCount = this.allies.filter(a => a.linked).length;
                stats.innerHTML = `
            SCORE: ${Math.floor(this.score)}<br>
            TIME LEFT: ${Math.floor(Math.max(0, this.time))}s<br>
            BOND: ${bondCount}/6 ALLIES<br>
            BOND GAUGE: ${Math.floor((bondCount / 6) * 100)}%
        `;
                
                // BGMåœæ­¢ï¼ˆçµæœç”»é¢ã§ã¯BGMãªã—ï¼‰
                this.stopBGM();
            }
        }

        /**
         * Entities
         */
        class Entity {
            constructor(game, x, y) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.dead = false;
            }
        }

        class Player extends Entity {
            constructor(game) {
                super(game, game.baseWidth / 2, game.baseHeight / 2);
                this.baseSpeed = 300;
                this.speed = 300;
                this.baseAttack = 1.0;
                this.attackMultiplier = 1.0;
                this.defenseMultiplier = 1.0;
                this.maxHp = 100;
                this.hp = this.maxHp;
                this.imgKey = 'player';
                this.shieldReduction = 0; // ã‚·ãƒ¼ãƒ«ãƒ‰ã«ã‚ˆã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸è»½æ¸›
            }

            takeDamage(amount) {
                // é˜²å¾¡åŠ›ã«å¿œã˜ã¦ãƒ€ãƒ¡ãƒ¼ã‚¸è»½æ¸›
                let actualDamage = amount / this.defenseMultiplier;
                
                // ã‚·ãƒ¼ãƒ«ãƒ‰åŠ¹æœã§ã•ã‚‰ã«è»½æ¸›
                if (this.shieldReduction) {
                    actualDamage *= (1 - this.shieldReduction);
                }
                
                this.hp -= actualDamage;
                if (this.hp <= 0) {
                    this.hp = 0;
                    this.dead = true;
                }
            }

            update(dt) {
                // ãƒªãƒ³ã‚¯ã—ã¦ã„ã‚‹ä»²é–“ã®èƒ½åŠ›ã‚’é©ç”¨
                const linkedAllies = this.game.allies.filter(a => a.linked && !a.dead);
                
                // åŸºæœ¬èƒ½åŠ›å€¤
                let speedBonus = 0;
                let attackBonus = 0;
                let defenseBonus = 0;
                let shieldReduction = 0;
                
                // ãƒªãƒ³ã‚¯æ•°ã«å¿œã˜ãŸæ®µéšçš„ãªè£œæ­£ã‚’è¨ˆç®—
                const linkedCount = linkedAllies.length;
                let defenseMultiplier = 1.0; // é˜²å¾¡åŠ›ã®å€ç‡
                let healAmount = 0; // å›å¾©é‡
                
                // 3äººä»¥ä¸Šã§1æ®µéšç›®ã€6äººã§2æ®µéšç›®
                if (linkedCount >= 6) {
                    defenseMultiplier = 1.5; // 6äººï¼šé˜²å¾¡åŠ›+50%ï¼ˆ2æ®µéšç›®ï¼‰
                    healAmount = 5; // 6äººï¼šæ¯ç§’5HPå›å¾©ï¼ˆ2æ®µéšç›®ï¼‰
                } else if (linkedCount >= 3) {
                    defenseMultiplier = 1.3; // 3äººï¼šé˜²å¾¡åŠ›+30%ï¼ˆ1æ®µéšç›®ï¼‰
                    healAmount = 3; // 3äººï¼šæ¯ç§’3HPå›å¾©ï¼ˆ1æ®µéšç›®ï¼‰
                }
                
                // å„ä»²é–“ã®èƒ½åŠ›ã‚’é©ç”¨
                linkedAllies.forEach(ally => {
                    switch(ally.ability) {
                        case 'attack':
                            attackBonus += ally.abilityValue;
                            break;
                        case 'defense':
                            // é˜²å¾¡åŠ›ã¯æ®µéšçš„ãªè£œæ­£ã‚’é©ç”¨
                            defenseBonus += ally.abilityValue * defenseMultiplier;
                            break;
                        case 'speed':
                            speedBonus += ally.abilityValue;
                            break;
                        case 'shield':
                            shieldReduction += ally.abilityValue;
                            break;
                        case 'attackSpeed':
                            // æ”»æ’ƒé »åº¦ã‚¢ãƒƒãƒ—ã¯Gameã‚¯ãƒ©ã‚¹ã§å‡¦ç†
                            break;
                        case 'heal':
                            // å›å¾©ã¯æ®µéšçš„ãªè£œæ­£ã‚’é©ç”¨
                            if (ally.healCooldown <= 0) {
                                const actualHeal = healAmount > 0 ? healAmount : ally.abilityValue;
                                this.hp = Math.min(this.maxHp, this.hp + actualHeal);
                                ally.healCooldown = 1.0; // 1ç§’ã”ã¨ã«å›å¾©
                            } else {
                                ally.healCooldown -= dt;
                            }
                            break;
                    }
                });
                
                // èƒ½åŠ›å€¤ã‚’é©ç”¨
                this.speed = this.baseSpeed * (1 + speedBonus); // é€Ÿåº¦ã‚¢ãƒƒãƒ—
                this.attackMultiplier = 1.0 + attackBonus; // æ”»æ’ƒåŠ›ã‚¢ãƒƒãƒ—
                this.defenseMultiplier = 1.0 + defenseBonus; // é˜²å¾¡åŠ›ã‚¢ãƒƒãƒ—
                
                // ã‚·ãƒ¼ãƒ«ãƒ‰åŠ¹æœï¼ˆãƒ€ãƒ¡ãƒ¼ã‚¸è»½æ¸›ï¼‰ã¯åˆ¥é€”å‡¦ç†
                this.shieldReduction = shieldReduction;
                
                // æ”»æ’ƒé »åº¦ã‚¢ãƒƒãƒ—ã‚’Gameã‚¯ãƒ©ã‚¹ã«åæ˜ 
                let attackSpeedBonus = 0;
                linkedAllies.forEach(ally => {
                    if (ally.ability === 'attackSpeed') {
                        attackSpeedBonus += ally.abilityValue;
                    }
                });
                this.game.attackSpeedBonus = attackSpeedBonus;
                
                // æ”»æ’ƒé »åº¦ã‚¢ãƒƒãƒ—ã‚’Gameã‚¯ãƒ©ã‚¹ã«åæ˜ 
                this.game.attackSpeedBonus = attackSpeedBonus;

                let dx = 0;
                let dy = 0;
                if (this.game.keys['ArrowLeft'] || this.game.keys['a']) dx = -1;
                if (this.game.keys['ArrowRight'] || this.game.keys['d']) dx = 1;
                if (this.game.keys['ArrowUp'] || this.game.keys['w']) dy = -1;
                if (this.game.keys['ArrowDown'] || this.game.keys['s']) dy = 1;

                // Normalize
                if (dx !== 0 || dy !== 0) {
                    const len = Math.sqrt(dx * dx + dy * dy);
                    dx /= len;
                    dy /= len;
                }

                this.x += dx * this.speed * dt;
                this.y += dy * this.speed * dt;

                // Boundary (ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚µã‚¤ã‚º64x64ã‚’è€ƒæ…®ï¼šä¸­å¿ƒã‹ã‚‰32pxãšã¤ã€åŸºæº–ã‚µã‚¤ã‚ºã§è¨ˆç®—)
                const spriteHalfWidth = 32;
                const spriteHalfHeight = 32;
                const uiHeight = 80;
                this.x = Math.max(spriteHalfWidth, Math.min(this.game.baseWidth - spriteHalfWidth, this.x));
                this.y = Math.max(spriteHalfHeight + uiHeight, Math.min(this.game.baseHeight - spriteHalfHeight, this.y)); // ä¸Šéƒ¨UIåˆ†80pxè€ƒæ…®
            }

            render(ctx) {
                const img = this.game.assets.get(this.imgKey);
                if (img) {
                    ctx.drawImage(img, this.x - 32, this.y - 32, 64, 64);
                } else {
                    ctx.fillStyle = 'cyan';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        class Ally extends Entity {
            constructor(game, x, y, typeConf) {
                super(game, x, y);
                this.typeConf = typeConf;
                this.linked = false;
                this.hadLinked = false; // ä¸€åº¦ã§ã‚‚ãƒªãƒ³ã‚¯ã—ãŸã“ã¨ãŒã‚ã‚‹ã‹
                this.wanderAngle = Math.random() * Math.PI * 2;
                this.wanderTimer = 0;
                this.relinkCooldown = 0; // Cooldown for damage
                this.maxHp = typeConf.hp; // ã‚¿ã‚¤ãƒ—ã”ã¨ã®HP
                this.hp = this.maxHp;
                this.ability = typeConf.ability; // èƒ½åŠ›ã‚¿ã‚¤ãƒ—
                this.abilityValue = typeConf.abilityValue; // èƒ½åŠ›å€¤
                this.healCooldown = 0; // å›å¾©ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
            }

            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.hp = 0;
                    this.dead = true;
                    // ãƒªãƒ³ã‚¯ãŒåˆ‡ã‚Œã¦ã„ã‚‹å ´åˆã¯ãƒªãƒ³ã‚¯ã‚’è§£é™¤
                    if (this.linked) {
                        this.linked = false;
                    }
                }
            }

            update(dt) {
                if (this.relinkCooldown > 0) this.relinkCooldown -= dt;

                const dist = Math.hypot(this.game.player.x - this.x, this.game.player.y - this.y);

                // ãƒªãƒ³ã‚¯è·é›¢150pxä»¥å†…ï¼ˆç”»åƒã‚’ä½¿ã‚ãšã€ã‚ˆã‚Šé›¢ã‚Œã¦ã‚‚ç¶­æŒï¼‰
                const linkDistance = 150;
                const breakDistance = 350; // åˆ‡æ–­è·é›¢ã‚’åºƒã’ã¦åˆ‡ã‚Œã«ããã™ã‚‹ï¼ˆãƒ’ã‚¹ãƒ†ãƒªã‚·ã‚¹ï¼‰
                if (dist < linkDistance && this.relinkCooldown <= 0) {
                    if (!this.linked) {
                        this.linked = true;
                        this.hadLinked = true; // ä¸€åº¦ãƒªãƒ³ã‚¯ã—ãŸã“ã¨ã‚’è¨˜éŒ²
                        this.game.score += 100;
                        this.game.effects.push(new Effect(this.game, this.x, this.y, 'bond_link'));
                    }
                } else if (dist > breakDistance) {
                    // è·é›¢è¶…éã§ãƒªãƒ³ã‚¯åˆ‡æ–­ï¼ˆãƒ’ã‚¹ãƒ†ãƒªã‚·ã‚¹ã‚ã‚Šï¼š150pxã§ãƒªãƒ³ã‚¯ã€350pxã§åˆ‡æ–­ï¼‰
                    // ã‚ˆã‚Šé›¢ã‚Œãªã„ã¨åˆ‡ã‚Œãªã„ã‚ˆã†ã«èª¿æ•´
                    if (this.linked) {
                        this.linked = false;
                    }
                }

                if (this.linked) {
                    // Follow player in formation
                    const angle = Math.atan2(this.game.player.y - this.y, this.game.player.x - this.x);
                    const targetDist = 60;
                    const tx = this.game.player.x - Math.cos(angle) * targetDist;
                    const ty = this.game.player.y - Math.sin(angle) * targetDist;

                    this.x += (tx - this.x) * 2 * dt;
                    this.y += (ty - this.y) * 2 * dt;
                    
                    // Boundary check (ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚µã‚¤ã‚º48x48ã‚’è€ƒæ…®ï¼šä¸­å¿ƒã‹ã‚‰24pxãšã¤ã€åŸºæº–ã‚µã‚¤ã‚ºã§è¨ˆç®—)
                    const spriteHalfWidth = 24;
                    const spriteHalfHeight = 24;
                    const uiHeight = 80;
                    this.x = Math.max(spriteHalfWidth, Math.min(this.game.baseWidth - spriteHalfWidth, this.x));
                    this.y = Math.max(spriteHalfHeight + uiHeight, Math.min(this.game.baseHeight - spriteHalfHeight, this.y)); // ä¸Šéƒ¨UIåˆ†80pxè€ƒæ…®
                } else {
                    // Wander
                    this.wanderTimer -= dt;
                    if (this.wanderTimer <= 0) {
                        this.wanderAngle += (Math.random() - 0.5) * 2;
                        this.wanderTimer = 1;
                    }
                    this.x += Math.cos(this.wanderAngle) * 50 * dt;
                    this.y += Math.sin(this.wanderAngle) * 50 * dt;

                    // Boundary check (ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚µã‚¤ã‚º48x48ã‚’è€ƒæ…®ï¼šä¸­å¿ƒã‹ã‚‰24pxãšã¤ã€åŸºæº–ã‚µã‚¤ã‚ºã§è¨ˆç®—)
                    const spriteHalfWidth = 24;
                    const spriteHalfHeight = 24;
                    const uiHeight = 80;
                    if (this.x < spriteHalfWidth) { 
                        this.x = spriteHalfWidth; 
                        this.wanderAngle = Math.PI - this.wanderAngle; 
                    }
                    if (this.x > this.game.baseWidth - spriteHalfWidth) { 
                        this.x = this.game.baseWidth - spriteHalfWidth; 
                        this.wanderAngle = Math.PI - this.wanderAngle; 
                    }
                    if (this.y < spriteHalfHeight + uiHeight) { 
                        this.y = spriteHalfHeight + uiHeight; 
                        this.wanderAngle = -this.wanderAngle; 
                    }
                    if (this.y > this.game.baseHeight - spriteHalfHeight) { 
                        this.y = this.game.baseHeight - spriteHalfHeight; 
                        this.wanderAngle = -this.wanderAngle; 
                    }
                }
            }

            render(ctx) {
                let key = `sol${this.typeConf.id}_`;
                key += this.linked ? 'l' : 'n'; // TODO: Damage state '_d'
                const img = this.game.assets.get(key);

                if (img) {
                    ctx.drawImage(img, this.x - 24, this.y - 24, 48, 48);
                } else {
                    ctx.fillStyle = this.linked ? '#ff00ff' : '#aaaaaa';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        class Boss extends Entity {
            constructor(game) {
                super(game, game.baseWidth / 2, 150);
                // é›£æ˜“åº¦ã«å¿œã˜ã¦ä½“åŠ›ã‚’è¨­å®š
                const baseHp = 20000;
                this.maxHp = game.difficulty === 'hard' ? baseHp * 8 : baseHp; // ãƒãƒ¼ãƒ‰ï¼š8å€ã€ãƒãƒ¼ãƒãƒ«ï¼šé€šå¸¸
                this.hp = this.maxHp;
                this.phase = 1;
                this.shootTimer = 0;
                this.moveTimer = 0;
                this.attackPattern = 0; // æ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç¨®é¡
                this.gameStartTime = performance.now(); // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚åˆ»ã‚’è¨˜éŒ²
            }

            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.dead = true;
                    this.game.effects.push(new Effect(this.game, this.x, this.y, 'explosion'));
                }
            }

            update(dt) {
                if (this.dead) return;

                // Move
                this.moveTimer += dt;
                this.x = this.game.baseWidth / 2 + Math.sin(this.moveTimer) * 300;

                // Attack
                this.shootTimer -= dt;
                if (this.shootTimer <= 0) {
                    this.attack();
                    this.shootTimer = this.getFireRate();
                }

                // Phase check
                const pct = this.hp / this.maxHp;
                if (pct < 0.3) this.phase = 3;
                else if (pct < 0.6) this.phase = 2;
                else this.phase = 1;
            }

            getFireRate() {
                // æ”»æ’ƒé »åº¦ã‚’å¾ã€…ã«ä¸Šã’ã‚‹ï¼ˆæ™‚é–“çµŒéã¨HPæ¸›å°‘ã«å¿œã˜ã¦ï¼‰
                const gameElapsedTime = (performance.now() - this.gameStartTime) / 1000; // ç§’
                const timeFactor = Math.min(1.0, gameElapsedTime / 120); // 2åˆ†ã§æœ€å¤§å€¤ã«
                
                // HPæ¸›å°‘ã«ã‚ˆã‚‹é »åº¦ã‚¢ãƒƒãƒ—
                const hpPct = this.hp / this.maxHp;
                const hpFactor = 1.0 - hpPct; // HPãŒæ¸›ã‚‹ã»ã©1ã«è¿‘ã¥ã
                
                // ãƒ•ã‚§ã‚¤ã‚ºã”ã¨ã®åŸºæœ¬é–“éš”
                let baseInterval;
                if (this.phase === 3) {
                    baseInterval = 0.35;  // Phase 3: 0.35ç§’é–“éš”ï¼ˆå°‘ã—ä¸‹ã’ã‚‹ï¼‰
                } else if (this.phase === 2) {
                    baseInterval = 0.5;   // Phase 2: 0.5ç§’é–“éš”
                } else {
                    baseInterval = 0.7;  // Phase 1: 0.7ç§’é–“éš”
                }
                
                // æ™‚é–“çµŒéã¨HPæ¸›å°‘ã«å¿œã˜ã¦ã•ã‚‰ã«çŸ­ç¸®ï¼ˆæœ€å¾Œã®æ–¹ã®é »åº¦ã‚’æŠ‘ãˆã‚‹ï¼‰
                const reduction = (timeFactor * 0.2) + (hpFactor * 0.15); // æœ€å¤§0.35ç§’çŸ­ç¸®ï¼ˆä»¥å‰ã‚ˆã‚Šå°‘ãªãï¼‰
                const finalInterval = Math.max(0.25, baseInterval - reduction); // æœ€å°0.25ç§’ï¼ˆä»¥å‰ã‚ˆã‚Šé•·ãï¼‰
                
                return finalInterval;
            }

            attack() {
                // æ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
                this.attackPattern = (this.attackPattern + 1) % 4;
                
                if (this.phase === 1) {
                    // Phase 1: åŸºæœ¬çš„ãªæ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³
                    if (this.attackPattern === 0) {
                        // ç›´ç·šãƒ“ãƒ¼ãƒ ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç‹™ã„ï¼‰
                        this.game.bullets.push(new Bullet(this.game, this.x, this.y, this.game.player.x, this.game.player.y, 'beam_straight'));
                    } else if (this.attackPattern === 1) {
                        // 3æ–¹å‘æ‹¡æ•£
                        for (let i = -1; i <= 1; i++) {
                            const angle = Math.atan2(this.game.player.y - this.y, this.game.player.x - this.x) + i * 0.3;
                            this.game.bullets.push(new Bullet(this.game, this.x, this.y,
                                this.x + Math.cos(angle) * 100, this.y + Math.sin(angle) * 100,
                                'beam_straight', angle));
                        }
                    } else if (this.attackPattern === 2) {
                        // 5æ–¹å‘æ‹¡æ•£
                        for (let i = -2; i <= 2; i++) {
                            const angle = Math.atan2(this.game.player.y - this.y, this.game.player.x - this.x) + i * 0.2;
                            this.game.bullets.push(new Bullet(this.game, this.x, this.y,
                                this.x + Math.cos(angle) * 100, this.y + Math.sin(angle) * 100,
                                'beam_spread', angle));
                        }
                    } else {
                        // å††å½¢æ”¾å°„
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI / 3) + (Date.now() / 1000);
                            this.game.bullets.push(new Bullet(this.game, this.x, this.y,
                                this.x + Math.cos(angle) * 100, this.y + Math.sin(angle) * 100,
                                'beam_spread', angle));
                        }
                    }
                } else if (this.phase === 2) {
                    // Phase 2: ã‚ˆã‚Šæ¿€ã—ã„æ”»æ’ƒ
                    if (this.attackPattern === 0) {
                        // 5æ–¹å‘æ‹¡æ•£ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä¸­å¿ƒï¼‰
                        for (let i = -2; i <= 2; i++) {
                            const angle = Math.atan2(this.game.player.y - this.y, this.game.player.x - this.x) + i * 0.25;
                            this.game.bullets.push(new Bullet(this.game, this.x, this.y,
                                this.x + Math.cos(angle) * 100, this.y + Math.sin(angle) * 100,
                                'beam_spread', angle));
                        }
                    } else if (this.attackPattern === 1) {
                        // 8æ–¹å‘æ”¾å°„
                        for (let i = 0; i < 8; i++) {
                            const angle = (i * Math.PI / 4) + (Date.now() / 800);
                            this.game.bullets.push(new Bullet(this.game, this.x, this.y,
                                this.x + Math.cos(angle) * 100, this.y + Math.sin(angle) * 100,
                                'beam_spread', angle));
                        }
                    } else if (this.attackPattern === 2) {
                        // 2æ®µéšæ‹¡æ•£
                        for (let i = -3; i <= 3; i++) {
                            const angle = Math.atan2(this.game.player.y - this.y, this.game.player.x - this.x) + i * 0.15;
                            this.game.bullets.push(new Bullet(this.game, this.x, this.y,
                                this.x + Math.cos(angle) * 100, this.y + Math.sin(angle) * 100,
                                'beam_spread', angle));
                        }
                    } else {
                        // å›è»¢ã™ã‚‹å††å½¢æ”¾å°„
                        for (let i = 0; i < 10; i++) {
                            const angle = (i * Math.PI / 5) + (Date.now() / 600);
                            this.game.bullets.push(new Bullet(this.game, this.x, this.y,
                                this.x + Math.cos(angle) * 100, this.y + Math.sin(angle) * 100,
                                'beam_homing', angle));
                        }
                    }
                } else {
                    // Phase 3: æœ€æ¿€ã—ã„æ”»æ’ƒ
                    if (this.attackPattern === 0) {
                        // å…¨æ–¹ä½12æ–¹å‘
                        for (let i = 0; i < 12; i++) {
                            const angle = (i * Math.PI / 6) + (Date.now() / 500);
                            this.game.bullets.push(new Bullet(this.game, this.x, this.y,
                                this.x + Math.cos(angle) * 100, this.y + Math.sin(angle) * 100,
                                'beam_homing', angle));
                        }
                    } else if (this.attackPattern === 1) {
                        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç‹™ã„ + æ‹¡æ•£
                        this.game.bullets.push(new Bullet(this.game, this.x, this.y, this.game.player.x, this.game.player.y, 'beam_straight'));
                        for (let i = -3; i <= 3; i++) {
                            if (i === 0) continue;
                            const angle = Math.atan2(this.game.player.y - this.y, this.game.player.x - this.x) + i * 0.2;
                            this.game.bullets.push(new Bullet(this.game, this.x, this.y,
                                this.x + Math.cos(angle) * 100, this.y + Math.sin(angle) * 100,
                                'beam_homing', angle));
                        }
                    } else if (this.attackPattern === 2) {
                        // 16æ–¹å‘å…¨æ–¹ä½
                        for (let i = 0; i < 16; i++) {
                            const angle = (i * Math.PI / 8) + (Date.now() / 400);
                            this.game.bullets.push(new Bullet(this.game, this.x, this.y,
                                this.x + Math.cos(angle) * 100, this.y + Math.sin(angle) * 100,
                                'beam_homing', angle));
                        }
                    } else {
                        // è¤‡åˆæ”»æ’ƒï¼šå††å½¢ + ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç‹™ã„
                        for (let i = 0; i < 8; i++) {
                            const angle = (i * Math.PI / 4) + (Date.now() / 500);
                            this.game.bullets.push(new Bullet(this.game, this.x, this.y,
                                this.x + Math.cos(angle) * 100, this.y + Math.sin(angle) * 100,
                                'beam_homing', angle));
                        }
                        this.game.bullets.push(new Bullet(this.game, this.x, this.y, this.game.player.x, this.game.player.y, 'beam_straight'));
                    }
                }
            }

            render(ctx) {
                if (this.dead) return;
                const img = this.game.assets.get('enemy');
                if (img) {
                    // Tint based on phase? (Canvas standard doesn't support easy tint without perf cost, so we simulate phase with behavior mainly)
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    // Wobble
                    if (this.phase === 3) ctx.rotate((Math.random() - 0.5) * 0.1);
                    ctx.drawImage(img, -100, -100, 200, 200); // Assume large boss sprite
                    ctx.restore();
                } else {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x - 50, this.y - 50, 100, 100);
                }

                // HP Bar (ç”»é¢ä¸Šéƒ¨ã«å›ºå®šè¡¨ç¤º)
                const pct = Math.max(0, this.hp / this.maxHp);
                const barWidth = 400;
                const barHeight = 20;
                const barX = this.game.baseWidth / 2 - barWidth / 2; // ç”»é¢ä¸­å¤®ã«å›ºå®š
                const barY = 90; // ç”»é¢ä¸Šéƒ¨ï¼ˆUIãƒ˜ãƒƒãƒ€ãƒ¼ã®ä¸‹ï¼‰ã«å›ºå®š
                
                // HPãƒãƒ¼ã®èƒŒæ™¯
                ctx.fillStyle = '#333';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // HPãƒãƒ¼ã®å¡—ã‚Šã¤ã¶ã—
                ctx.fillStyle = pct < 0.3 ? 'red' : pct < 0.6 ? 'orange' : 'green';
                ctx.fillRect(barX, barY, barWidth * pct, barHeight);
                
                // HPãƒãƒ¼ã®æ ç·š
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                // HPæ•°å€¤ã‚’è¡¨ç¤º
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const hpText = `${Math.floor(this.hp)} / ${Math.floor(this.maxHp)}`;
                ctx.fillText(hpText, this.game.baseWidth / 2, barY - 15);
                
                // ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸ã‚‚è¡¨ç¤º
                const percentText = `${Math.floor(pct * 100)}%`;
                ctx.font = 'bold 14px Arial';
                ctx.fillText(percentText, this.game.baseWidth / 2, barY + barHeight + 15);
            }
        }

        class Bullet extends Entity {
            constructor(game, x, y, tx, ty, type, forcedAngle = null) {
                super(game, x, y);
                this.type = type; // 'beam_straight', 'beam_spread', 'beam_homing'
                this.speed = 150;
                this.lifeTime = 0; // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨

                const angle = forcedAngle !== null ? forcedAngle : Math.atan2(ty - y, tx - x);
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.rot = angle;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.lifeTime += dt;

                if (this.x < -100 || this.x > this.game.baseWidth + 100 ||
                    this.y < -100 || this.y > this.game.baseHeight + 100) {
                    this.dead = true;
                }

                // Hit Player and Allies
                const hitRadius = 20;
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å½“ãŸã£ãŸå ´åˆ
                const dPlayer = Math.hypot(this.game.player.x - this.x, this.game.player.y - this.y);
                if (dPlayer < hitRadius) {
                    this.dead = true;
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆé˜²å¾¡åŠ›ã§è»½æ¸›ã•ã‚Œã‚‹ï¼‰
                    this.game.player.takeDamage(20);
                    // Break bonds - æ•µå¼¾å‘½ä¸­ã§çµ†åˆ‡æ–­
                    const linked = this.game.allies.filter(a => a.linked && !a.dead);
                    if (linked.length > 0) {
                        // Unlink random one
                        const target = linked[Math.floor(Math.random() * linked.length)];
                        target.linked = false;
                        target.relinkCooldown = 2.0; // 2 seconds cooldown
                        this.game.effects.push(new Effect(this.game, target.x, target.y, 'bond_dam'));
                    }
                    this.game.effects.push(new Effect(this.game, this.x, this.y, 'bond_dam'));
                    return; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å½“ãŸã£ãŸã‚‰å‡¦ç†çµ‚äº†
                }

                // ä»²é–“ã«å½“ãŸã£ãŸå ´åˆï¼ˆãƒªãƒ³ã‚¯ã—ã¦ã„ã‚‹ã¨ãã®ã¿ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰
                for (let i = 0; i < this.game.allies.length; i++) {
                    const ally = this.game.allies[i];
                    if (ally.dead) continue;
                    if (!ally.linked) continue; // ãƒªãƒ³ã‚¯ã—ã¦ã„ãªã„å ´åˆã¯ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãªã„
                    
                    const dAlly = Math.hypot(ally.x - this.x, ally.y - this.y);
                    if (dAlly < hitRadius) {
                        this.dead = true;
                        // ä»²é–“ã«ãƒ€ãƒ¡ãƒ¼ã‚¸
                        ally.takeDamage(15);
                        // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                        this.game.effects.push(new Effect(this.game, ally.x, ally.y, 'bond_dam'));
                        
                        // ä»²é–“ãŒå€’ã‚ŒãŸå ´åˆã®å‡¦ç†
                        if (ally.dead) {
                            // ãƒªãƒ³ã‚¯ã‚’è§£é™¤
                            ally.linked = false;
                            // å€’ã‚ŒãŸã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                            this.game.effects.push(new Effect(this.game, ally.x, ally.y, 'explosion'));
                        }
                        return; // ä»²é–“ã«å½“ãŸã£ãŸã‚‰å‡¦ç†çµ‚äº†
                    }
                }
            }

            render(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rot);

                // å¼¾ã®ç¨®é¡ã«å¿œã˜ã¦ç•°ãªã‚‹æç”»
                if (this.type === 'beam_straight') {
                    // ç›´ç·šãƒ“ãƒ¼ãƒ ï¼šç´°é•·ã„å…‰ã®å¼¾
                    const gradient = ctx.createLinearGradient(-20, 0, 20, 0);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 200, 100, 1)');
                    gradient.addColorStop(1, 'rgba(255, 100, 100, 0.8)');
                    
                    ctx.fillStyle = gradient;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(255, 200, 100, 0.8)';
                    ctx.fillRect(-20, -4, 40, 8);
                    
                    // ä¸­å¿ƒã®ã‚³ã‚¢
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                    ctx.fillRect(-15, -2, 30, 4);
                } else if (this.type === 'beam_spread') {
                    // æ‹¡æ•£ãƒ“ãƒ¼ãƒ ï¼šæ˜Ÿå‹ã®å…‰å¼¾
                    const pulse = Math.sin(this.lifeTime * 10) * 0.3 + 0.7;
                    const size = 8 * pulse;
                    
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    gradient.addColorStop(0.5, 'rgba(200, 150, 255, 0.8)');
                    gradient.addColorStop(1, 'rgba(150, 100, 255, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'rgba(200, 150, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // æ˜Ÿå‹ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(i * Math.PI / 2) * size * 1.5, Math.sin(i * Math.PI / 2) * size * 1.5);
                        ctx.stroke();
                    }
                } else if (this.type === 'beam_homing') {
                    // è¿½å°¾ãƒ“ãƒ¼ãƒ ï¼šå›è»¢ã™ã‚‹å…‰ã®è¼ª
                    const rotation = this.lifeTime * 5;
                    const size = 10;
                    
                    ctx.save();
                    ctx.rotate(rotation);
                    
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    gradient.addColorStop(0.3, 'rgba(100, 200, 255, 0.9)');
                    gradient.addColorStop(1, 'rgba(50, 150, 255, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = 'rgba(100, 200, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // å›è»¢ã™ã‚‹ãƒªãƒ³ã‚°
                    ctx.strokeStyle = 'rgba(150, 220, 255, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.restore();
                } else {
                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼šã‚·ãƒ³ãƒ—ãƒ«ãªå…‰å¼¾
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 8);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    gradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 100, 100, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(255, 200, 100, 0.8)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        class BondAttackBeam extends Entity {
            constructor(game, fromX, fromY, toX, toY) {
                super(game, fromX, fromY);
                this.fromX = fromX;
                this.fromY = fromY;
                this.toX = toX;
                this.toY = toY;
                this.timer = 0;
                this.maxTime = 0.3; // ãƒ“ãƒ¼ãƒ ã®æŒç¶šæ™‚é–“
                this.progress = 0; // 0ã‹ã‚‰1ã¸
            }

            update(dt) {
                this.timer += dt;
                this.progress = Math.min(1, this.timer / this.maxTime);
                if (this.timer >= this.maxTime) this.dead = true;
            }

            render(ctx) {
                const currentX = this.fromX + (this.toX - this.fromX) * this.progress;
                const currentY = this.fromY + (this.toY - this.fromY) * this.progress;
                
                // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ“ãƒ¼ãƒ 
                const gradient = ctx.createLinearGradient(
                    this.fromX, this.fromY,
                    currentX, currentY
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                gradient.addColorStop(0.3, 'rgba(200, 150, 255, 0.8)');
                gradient.addColorStop(0.7, 'rgba(150, 100, 255, 0.6)');
                gradient.addColorStop(1, 'rgba(100, 50, 255, 0.4)');
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'rgba(200, 150, 255, 0.8)';
                ctx.beginPath();
                ctx.moveTo(this.fromX, this.fromY);
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                
                // å…ˆç«¯ã®å…‰çƒ
                const glowSize = 15 * (1 - this.progress);
                if (glowSize > 0) {
                    const glowGradient = ctx.createRadialGradient(
                        currentX, currentY, 0,
                        currentX, currentY, glowSize
                    );
                    glowGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    glowGradient.addColorStop(0.5, 'rgba(200, 150, 255, 0.6)');
                    glowGradient.addColorStop(1, 'rgba(150, 100, 255, 0)');
                    
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(currentX, currentY, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.shadowBlur = 0;
            }
        }

        class BossHitEffect extends Entity {
            constructor(game, x, y) {
                super(game, x, y);
                this.timer = 0;
                this.maxTime = 0.4; // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æŒç¶šæ™‚é–“
            }

            update(dt) {
                this.timer += dt;
                if (this.timer >= this.maxTime) this.dead = true;
            }

            render(ctx) {
                const progress = this.timer / this.maxTime;
                const size = 60 * (1 - progress * 0.5); // å¾ã€…ã«å°ã•ããªã‚‹
                const alpha = 1 - progress;

                // å¤–å´ã®ãƒªãƒ³ã‚°
                ctx.strokeStyle = `rgba(255, 200, 100, ${alpha * 0.8})`;
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'rgba(255, 200, 100, 0.8)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.stroke();

                // å†…å´ã®å…‰çƒ
                const innerGradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, size * 0.6
                );
                innerGradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                innerGradient.addColorStop(0.5, `rgba(255, 200, 100, ${alpha * 0.6})`);
                innerGradient.addColorStop(1, `rgba(255, 150, 50, 0)`);

                ctx.fillStyle = innerGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size * 0.6, 0, Math.PI * 2);
                ctx.fill();

                // ç«èŠ±ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    const angle = (i * Math.PI * 2 / 8) + progress * Math.PI * 2;
                    const sparkLength = size * 0.8;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(
                        this.x + Math.cos(angle) * sparkLength,
                        this.y + Math.sin(angle) * sparkLength
                    );
                    ctx.stroke();
                }

                ctx.shadowBlur = 0;
            }
        }

        class Effect extends Entity {
            constructor(game, x, y, type) {
                super(game, x, y);
                this.type = type;
                this.timer = 0;
                this.maxTime = 0.5; // seconds

                // explosionã‚¿ã‚¤ãƒ—ã§ã‚‚ç”»åƒã‚’ä½¿ã‚ãªã„
                this.isSheet = false;
                this.frames = 6;
            }

            update(dt) {
                this.timer += dt;
                if (this.timer >= this.maxTime) this.dead = true;
            }

            render(ctx) {
                // explosionã‚¿ã‚¤ãƒ—ã¯Canvasæç”»ã§è¡¨ç¤º
                if (this.type === 'explosion') {
                    const progress = this.timer / this.maxTime;
                    const size = 40 * (1 - progress * 0.3);
                    const alpha = 1 - progress;

                    // çˆ†ç™ºã®ãƒªãƒ³ã‚°
                    ctx.strokeStyle = `rgba(255, 150, 50, ${alpha * 0.8})`;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(255, 150, 50, 0.6)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                    ctx.stroke();

                    // ä¸­å¿ƒã®å…‰çƒ
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, size * 0.7
                    );
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                    gradient.addColorStop(0.5, `rgba(255, 200, 100, ${alpha * 0.7})`);
                    gradient.addColorStop(1, `rgba(255, 150, 50, 0)`);

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size * 0.7, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.shadowBlur = 0;
                } else {
                    // ãã®ä»–ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆbond_link, bond_damãªã©ï¼‰ã¯ç”»åƒã‚’ä½¿ç”¨
                    const img = this.game.assets.get(this.type);
                    if (img) {
                        ctx.globalAlpha = 1 - (this.timer / this.maxTime);
                        ctx.drawImage(img, this.x - 16, this.y - 16, 32, 32);
                        ctx.globalAlpha = 1;
                    }
                }
            }
        }

        const game = new Game();

    </script>
</body>

</html>